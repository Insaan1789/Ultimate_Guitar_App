<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Guitar App</title>
    <!-- Google Fonts for Modern Typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&display=swap" rel="stylesheet">

    <style>
        /* CSS Variables - Dark Mode Default */
        :root {
            /* Colors */
            --bg-primary: #121212;
            --bg-secondary: #1E1E1E;
            --bg-tertiary: #2C2C2C;
            --text-primary: #FFFFFF;
            --text-secondary: #AAAAAA;
            --accent-primary: #00E676;
            /* Vibrant Green */
            --accent-hover: #00C853;
            --danger: #FF5252;
            --warning: #FFAB40;
            /* Orange for Flat */
            --surface-border: #333333;

            /* Dimensions */
            --nav-width-desktop: 250px;
            --nav-height-mobile: 64px;
            --header-height: 60px;

            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;

            /* Transitions */
            --transition-speed: 0.2s;
        }

        /* Reset & Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            /* Prevent body scroll, handle inside main */
            height: 100vh;
            width: 100vw;
        }

        /* Layout Structure */
        #app-container {
            display: flex;
            height: 100%;
            width: 100%;
            flex-direction: column;
            /* Default to mobile (column with bottom bar - implemented via ordering) */
        }

        /* Responsive Navigation */
        #main-nav {
            background-color: var(--bg-secondary);
            border-top: 1px solid var(--surface-border);
            /* Mobile: Fixed at bottom */
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--nav-height-mobile);
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 1000;
        }

        #content-area {
            flex: 1;
            overflow-y: auto;
            padding: var(--spacing-md);
            /* Mobile: Add padding bottom for nav bar */
            padding-bottom: calc(var(--nav-height-mobile) + var(--spacing-md));
            background-color: var(--bg-primary);
        }

        /* Nav Interface */
        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color var(--transition-speed);
            flex: 1;
            height: 100%;
        }

        .nav-item:hover {
            color: var(--text-primary);
        }

        .nav-item.active {
            color: var(--accent-primary);
        }

        .nav-icon {
            font-size: 24px;
            margin-bottom: 2px;
            /* Placeholder for icons, using text for now or SVGs */
            display: block;
        }

        .nav-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        /* Desktop Layout (>= 768px) */
        @media (min-width: 768px) {
            #app-container {
                flex-direction: row;
            }

            #main-nav {
                position: relative;
                /* Not fixed anymore */
                width: var(--nav-width-desktop);
                height: 100%;
                flex-direction: column;
                justify-content: flex-start;
                padding-top: var(--spacing-xl);
                border-top: none;
                border-right: 1px solid var(--surface-border);
            }

            #content-area {
                padding-bottom: var(--spacing-md);
                /* Reset padding */
            }

            .nav-item {
                flex-direction: row;
                width: 100%;
                height: 60px;
                flex: 0 0 auto;
                padding: 0 var(--spacing-lg);
                justify-content: flex-start;
                gap: var(--spacing-md);
            }

            .nav-icon {
                font-size: 20px;
                margin-bottom: 0;
            }

            .nav-label {
                font-size: 16px;
                text-transform: none;
                font-weight: 400;
            }

            /* Logo Area for Desktop (Optional) */
            .nav-header {
                padding: 0 var(--spacing-lg) var(--spacing-xl);
                font-size: 24px;
                font-weight: 700;
                color: var(--accent-primary);
            }
        }

        /* Section Styling */
        section {
            display: none;
            /* Hidden by default */
            max-width: 1200px;
            margin: 0 auto;
            /* Animation */
            animation: fadeIn 0.3s ease-in-out;
        }

        section.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .section-header {
            margin-bottom: var(--spacing-lg);
        }

        .section-title {
            font-size: 32px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .section-subtitle {
            font-size: 16px;
            color: var(--text-secondary);
        }

        /* Card Grid System */
        .card-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--spacing-md);
        }

        @media (min-width: 600px) {
            .card-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (min-width: 1024px) {
            .card-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        /* Placeholder Cards */
        .card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--surface-border);
            border-radius: 12px;
            padding: var(--spacing-lg);
            cursor: pointer;
            transition: transform var(--transition-speed), border-color var(--transition-speed);
        }

        .card:hover {
            transform: translateY(-4px);
            border-color: var(--accent-primary);
        }

        .card:active {
            transform: translateY(0);
        }

        .card h3 {
            font-size: 20px;
            margin-bottom: var(--spacing-sm);
            color: var(--text-primary);
        }

        .card p {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        /* Utility Classes */
        .hidden {
            display: none !important;
        }

        /* Error / Fallback UI */
        .error-message {
            background-color: rgba(255, 82, 82, 0.1);
            color: var(--danger);
            padding: var(--spacing-md);
            border-radius: 8px;
            text-align: center;
            margin-top: 20px;
        }

        /* =========================================
           TUNER MODULE STYLES
           ========================================= */
        #tuner-view {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            height: 100%;
        }

        .tuner-top-bar {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .back-btn {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 24px;
            cursor: pointer;
            padding: var(--spacing-xs);
        }

        .tuner-controls {
            display: flex;
            gap: var(--spacing-md);
            flex-wrap: wrap;
        }

        .tuner-select {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--surface-border);
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
        }

        .tuner-display {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-xl) 0;
            position: relative;
        }

        .note-name {
            font-size: 96px;
            font-weight: 700;
            color: var(--text-secondary);
            /* Default dim */
            transition: color 0.1s;
        }

        .note-name.in-tune {
            color: var(--accent-primary);
        }

        .note-name.sharp {
            color: var(--danger);
        }

        .note-name.flat {
            color: var(--warning);
        }

        .octave {
            font-size: 32px;
            vertical-align: super;
            opacity: 0.7;
        }

        .cents-display {
            font-size: 24px;
            font-family: monospace;
            color: var(--text-secondary);
            margin-top: var(--spacing-sm);
        }

        /* Meter Assembly */
        .meter-container {
            width: 300px;
            height: 20px;
            background-color: var(--bg-tertiary);
            border-radius: 10px;
            position: relative;
            margin-top: var(--spacing-lg);
            overflow: hidden;
        }

        .center-marker {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: var(--text-secondary);
            transform: translateX(-50%);
            z-index: 10;
        }

        .needle {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 4px;
            background-color: var(--accent-primary);
            left: 50%;
            transform: translateX(-50%);
            transition: left 0.1s ease-out;
            box-shadow: 0 0 8px var(--accent-primary);
        }

        .needle.sharp {
            background-color: var(--danger);
            box-shadow: 0 0 8px var(--danger);
        }

        .needle.flat {
            background-color: var(--warning);
            box-shadow: 0 0 8px var(--warning);
        }

        /* Headstock / String Selector */
        .headstock-container {
            display: flex;
            justify-content: center;
            gap: var(--spacing-md);
            margin-top: var(--spacing-lg);
            flex-wrap: wrap;
        }

        .string-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: var(--bg-tertiary);
            border: 2px solid var(--surface-border);
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .string-btn:hover {
            border-color: var(--text-secondary);
        }

        .string-btn.active {
            background-color: var(--accent-primary);
            border-color: var(--accent-primary);
            color: #000;
        }

        .tuner-actions {
            display: flex;
            justify-content: center;
            gap: var(--spacing-md);
            margin-top: var(--spacing-xl);
        }

        .action-btn {
            padding: var(--spacing-sm) var(--spacing-lg);
            border-radius: 20px;
            border: 1px solid var(--surface-border);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            font-family: inherit;
        }

        .action-btn.primary {
            background-color: var(--accent-primary);
            color: #000;
            border: none;
            font-weight: 600;
        }

        /* Metronome Styles */
        .metro-container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            padding: 1rem;
            max-width: 500px;
            margin: 0 auto;
        }

        .beat-indicators {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        .beat-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--surface-light);
            transition: background 0.1s;
        }

        .beat-dot.active {
            background: var(--primary-color);
            box-shadow: 0 0 10px var(--primary-color);
        }

        .beat-dot.accent {
            background: #ff4444;
            box-shadow: 0 0 15px #ff4444;
        }

        .bpm-control-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1.5rem;
        }

        .bpm-display {
            text-align: center;
        }

        #bpm-val {
            display: block;
            font-size: 4rem;
            font-weight: 700;
            line-height: 1;
        }

        .bpm-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .adjust-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            /* Fixed var */
            border: 1px solid var(--surface-border);
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slider-wrapper {
            width: 100%;
            padding: 0 1rem;
        }

        #bpm-slider {
            width: 100%;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        #bpm-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            border: 2px solid white;
        }

        .metro-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .big-play {
            padding: 1rem 3rem;
            font-size: 1.2rem;
            min-width: 160px;
        }

        .metro-settings-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            background: var(--bg-tertiary);
            padding: 1.5rem;
            border-radius: 12px;
        }

        @media (min-width: 768px) {
            .metro-settings-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .setting-item label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .toggle-btn.active {
            background: var(--accent-primary);
            color: black;
            border-color: var(--accent-primary);
        }

        /* =========================================
           CHORD EXPLORER STYLES
           ========================================= */
        .chord-explorer-container {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-lg);
            max-width: 1000px;
            margin: 0 auto;
        }

        .chord-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: var(--spacing-md);
        }

        .chord-controls {
            display: flex;
            gap: var(--spacing-md);
            flex-wrap: wrap;
            background: var(--bg-tertiary);
            padding: var(--spacing-md);
            border-radius: 12px;
            width: 100%;
        }

        .chord-main-display {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-lg);
            align-items: center;
        }

        @media (min-width: 768px) {
            .chord-main-display {
                flex-direction: row;
                justify-content: center;
                align-items: flex-start;
            }
        }

        .canvas-container {
            background: var(--bg-secondary);
            padding: var(--spacing-md);
            border-radius: 12px;
            border: 1px solid var(--surface-border);
            display: flex;
            justify-content: center;
        }

        #chord-canvas {
            max-width: 100%;
            height: auto;
        }

        .chord-info-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            min-width: 250px;
        }

        .info-card {
            background: var(--bg-tertiary);
            padding: var(--spacing-md);
            border-radius: 8px;
        }

        .info-label {
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin-bottom: 4px;
        }

        .info-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .interval-badges {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .badge {
            background: var(--surface-border);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .fretboard-container {
            overflow-x: auto;
            background: var(--bg-tertiary);
            padding: var(--spacing-md);
            border-radius: 12px;
            margin-top: var(--spacing-md);
        }

        /* Practice Mode Styles */
        .practice-bar {
            background: var(--bg-secondary);
            border: 1px solid var(--accent-primary);
            padding: var(--spacing-md);
            border-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: var(--spacing-lg);
        }

        .timer-display {
            font-family: monospace;
            font-size: 2rem;
            color: var(--accent-primary);
        }

        /* v1.1 Search Styles */
        .chord-search-box {
            width: 100%;
            margin-bottom: var(--spacing-sm);
        }

        .chord-search-input {
            width: 100%;
            padding: var(--spacing-md);
            background: var(--bg-primary);
            border: 1px solid var(--surface-border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Outfit', sans-serif;
            font-size: 1.1rem;
            transition: border-color 0.2s;
        }

        .chord-search-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        /* Sub Nav */
        .sub-nav {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            border-bottom: 1px solid var(--surface-border);
            padding-bottom: 8px;
        }

        .sub-nav-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-family: 'Outfit';
            font-size: 1.1rem;
            cursor: pointer;
            padding: 8px 16px;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .sub-nav-btn.active {
            color: var(--accent-primary);
            background: var(--bg-tertiary);
            font-weight: bold;
        }

        .sub-nav-btn:hover {
            color: #fff;
        }

        /* Theory Wheel Styles */
        .theory-container {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-lg);
            align-items: center;
        }

        @media (min-width: 900px) {
            .theory-container {
                flex-direction: row;
                justify-content: center;
                align-items: flex-start;
            }
        }

        .wheel-wrap {
            position: relative;
            width: 320px;
            height: 320px;
            margin: 0 auto;
        }

        .wheel-svg {
            width: 100%;
            height: 100%;
            transform: rotate(-15deg);
            /* Offset so C is at top */
            overflow: visible;
        }

        .wheel-segment {
            fill: var(--bg-tertiary);
            stroke: var(--surface-border);
            stroke-width: 1;
            cursor: pointer;
            transition: fill 0.2s, transform 0.2s;
        }

        .wheel-segment:hover {
            fill: var(--bg-secondary);
            transform: scale(1.02);
            /* Slight pop */
        }

        .wheel-segment.active {
            fill: var(--accent-primary);
            stroke: var(--accent-primary);
        }

        .wheel-label {
            font-size: 14px;
            font-weight: 600;
            fill: var(--text-secondary);
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .wheel-segment.active+.wheel-label,
        .wheel-segment.active~.wheel-label-group .wheel-label {
            /* Complex selector might need JS class toggle on text if structure differs */
            fill: #000;
        }

        .wheel-center-btn {
            fill: var(--bg-secondary);
            stroke: var(--accent-primary);
            stroke-width: 2;
            cursor: pointer;
        }

        .theory-info-panel {
            flex: 1;
            max-width: 500px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .diatonic-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            /* 7 chords + dim? */
            gap: 8px;
        }

        .degree-card {
            background: var(--bg-tertiary);
            padding: 8px;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
        }

        .degree-card:hover {
            border-color: var(--accent-primary);
            background: var(--bg-secondary);
        }

        .degree-roman {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .degree-chord {
            font-weight: 700;
            color: var(--text-primary);
        }

        .theory-toggles {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 16px;
        }

        /* AI Lab Styles */
        .ai-view {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .ai-view.active {
            display: block;
        }

        .search-input {
            background: var(--bg-tertiary);
            border: 1px solid var(--surface-border);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            font-family: inherit;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.2s;
        }

        .search-input:focus {
            border-color: var(--accent-primary);
        }

        .tab-scroller {
            display: flex;
            gap: 20px;
            padding: 10px 0;
            /* Scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: var(--accent-primary) var(--bg-secondary);
        }

        .tab-scroller::-webkit-scrollbar {
            height: 8px;
        }

        .tab-scroller::-webkit-scrollbar-thumb {
            background: var(--accent-primary);
            border-radius: 4px;
        }

        .tab-card {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 8px;
            min-width: 250px;
            border: 1px solid transparent;
        }

        .tab-card:hover {
            border-color: var(--accent-primary);
        }

        .progression-card {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .scale-result-card {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 8px;
        }

        .confidence-meter {
            height: 4px;
            background: var(--bg-secondary);
            border-radius: 2px;
            margin-top: 5px;
            overflow: hidden;
        }

        .confidence-val {
            height: 100%;
            background: var(--accent-primary);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>

<body>
    <div id="app-container">
        <!-- Navigation -->
        <nav id="main-nav">
            <!-- Desktop Header (Hidden on Mobile via CSS) -->
            <div class="nav-header">ULTIMATE GUITAR</div><button class="nav-item" data-target="tools"><span
                    class="nav-icon">üõ†Ô∏è</span><span class="nav-label">Tools</span></button><button class="nav-item"
                data-target="learn"><span class="nav-icon">üéì</span><span class="nav-label">Learn</span></button><button
                class="nav-item" data-target="ai-lab"><span class="nav-icon">ü§ñ</span><span class="nav-label">AI
                    Lab</span></button><button class="nav-item" data-target="practice"><span
                    class="nav-icon">üé∏</span><span class="nav-label">Practice</span></button><button class="nav-item"
                data-target="jam"><span class="nav-icon">üéµ</span><span class="nav-label">Jam</span></button><button
                class="nav-item" data-target="profile"><span class="nav-icon">üë§</span><span
                    class="nav-label">Profile</span></button>
        </nav>
        <!-- Main Content Area -->
        <main id="content-area">
            <!-- Tools Section (Now contains Sub-Views) -->
            <section id="tools">
                <!-- Dashboard View -->
                <div id="tools-dashboard">
                    <header class="section-header">
                        <h1 class="section-title">Tools</h1>
                        <p class="section-subtitle">Essential utilities for every guitarist.</p>
                    </header>
                    <div class="card-grid">
                        <div class="card" onclick="tunerApp.open()">
                            <h3>Pro Tuner</h3>
                            <p>High-precision chromatic tuner with alternate tunings.</p>
                        </div>
                        <div class="card" onclick="metronomeApp.open()">
                            <h3>Metronome</h3>
                            <p>Keep flawless time with customizable beats and subdivisions.</p>
                        </div>
                        <div class="card">
                            <h3>Chord Library</h3>
                            <p>Discover thousands of chord variations and voicings.</p>
                        </div>
                    </div>
                </div>
                <!-- Tuner View (Hidden by Default) -->
                <div id="tuner-view" class="hidden">
                    <div class="tuner-top-bar"><button class="back-btn" onclick="tunerApp.close()">&#8592;
                        </button>
                        <h2>Pro Tuner</h2>
                    </div>
                    <div class="tuner-controls"><select id="tuner-instrument" class="tuner-select"
                            onchange="tunerApp.setInstrument(this.value)">
                            <!-- Populated by JS -->
                        </select><select id="tuner-tuning" class="tuner-select"
                            onchange="tunerApp.setTuning(this.value)">
                            <!-- Populated by JS -->
                        </select></div>
                    <div class="tuner-display">
                        <div class="note-name" id="note-display">--</div>
                        <div class="cents-display" id="cents-display">0 cents</div>
                        <div class="meter-container">
                            <div class="center-marker"></div>
                            <div class="needle" id="tuner-needle"></div>
                        </div>
                    </div>
                    <div class="headstock-container" id="string-selector">
                        <!-- Strings generated by JS -->
                    </div>
                    <div class="tuner-actions"><button class="action-btn" id="mode-toggle"
                            onclick="tunerApp.toggleMode()">Mode: Auto</button><button class="action-btn primary"
                            id="mic-toggle" onclick="tunerApp.toggleMic()">Start Tuner</button></div>
                </div>
                <!-- Metronome View (Hidden by Default) -->
                <div id="metronome-view" class="hidden">
                    <div class="tuner-top-bar"><button class="back-btn" onclick="metronomeApp.close()">&#8592;
                        </button>
                        <h2>Metronome</h2>
                    </div>
                    <div class="metro-container">
                        <!-- Visual Beats -->
                        <div class="beat-indicators" id="beat-container">
                            <div class="beat-dot"></div>
                            <div class="beat-dot"></div>
                            <div class="beat-dot"></div>
                            <div class="beat-dot"></div>
                        </div>
                        <!-- BPM Display -->
                        <div class="bpm-control-group"><button class="adjust-btn"
                                onclick="metronomeApp.adjustBPM(-1)">-</button>
                            <div class="bpm-display"><span id="bpm-val">120</span><span class="bpm-label">BPM</span>
                            </div><button class="adjust-btn" onclick="metronomeApp.adjustBPM(1)">+</button>
                        </div>
                        <!-- Slider -->
                        <div class="slider-wrapper"><input type="range" id="bpm-slider" min="30" max="300" value="120"
                                oninput="metronomeApp.setBPM(this.value)"></div>
                        <!-- Action Buttons -->
                        <div class="metro-actions"><button class="action-btn" id="tap-btn"
                                onclick="metronomeApp.tapTempo()">TAP</button><button
                                class="action-btn primary big-play" id="metro-toggle"
                                onclick="metronomeApp.toggle()">START </button>
                        </div>
                        <!-- Settings -->
                        <div class="metro-settings-grid">
                            <div class="setting-item">
                                <label>Subdivision</label><select id="metro-subdivision" class="tuner-select"
                                    onchange="metronomeApp.setSubdivision(this.value)">
                                    <option value="4">Quarter (1/4)</option>
                                    <option value="8">Eighth (1/8)</option>
                                    <option value="12">Triplet (1/3)
                                    </option>
                                </select>
                            </div>
                            <div class="setting-item">
                                <label>Accent</label><button class="tuner-select toggle-btn active"
                                    id="metro-accent-toggle" onclick="metronomeApp.toggleAccent()">ON
                                </button>
                            </div>
                            <div class="setting-item">
                                <label>Preset</label><select id="metro-preset" class="tuner-select"
                                    onchange="metronomeApp.loadPreset(this.value)">
                                    <option value="default">Default</option>
                                    <option value="rock">Rock</option>
                                    <option value="jazz">Jazz</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            <!-- Learn Section -->
            <section id="learn">
                <header class="section-header">
                    <h1 class="section-title">Learn</h1>
                    <p class="section-subtitle">Master chords, scales, and theory.</p>
                </header>

                <!-- Sub Navigation -->
                <div class="sub-nav">
                    <button class="sub-nav-btn active" data-view="chords"
                        onclick="uiController.switchLearnView('chords')">Chord Explorer</button>
                    <button class="sub-nav-btn" data-view="scales"
                        onclick="uiController.switchLearnView('scales')">Scale Explorer</button>
                    <button class="sub-nav-btn" data-view="theory"
                        onclick="uiController.switchLearnView('theory')">Theory Wheel</button>
                </div>

                <!-- CHORD EXPLORER -->
                <div id="view-chords" class="explorer-view active">
                    <div class="chord-explorer-container">
                        <!-- Controls -->
                        <div class="chord-controls">
                            <div class="chord-search-box">
                                <input type="text" id="chord-search" class="chord-search-input"
                                    placeholder="Search chord (e.g. Cm7, F#maj7, Gsus4)..."
                                    oninput="chordApp.handleSearch(this.value)">
                            </div>

                            <div class="control-group">
                                <label class="info-label">Root</label>
                                <select id="chord-root" class="tuner-select" onchange="chordApp.setRoot(this.value)">
                                    <!-- Populated by JS -->
                                </select>
                            </div>
                            <div class="control-group">
                                <label class="info-label">Type</label>
                                <select id="chord-type" class="tuner-select" onchange="chordApp.setType(this.value)">
                                    <!-- Populated by JS -->
                                </select>
                            </div>
                            <div style="flex:1;"></div>
                            <button class="action-btn" onclick="chordApp.prevPosition()"
                                title="Previous Position">&lt;</button>
                            <span class="info-value" style="align-self:center;" id="position-indicator">Pos 1/5</span>
                            <button class="action-btn" onclick="chordApp.nextPosition()"
                                title="Next Position">&gt;</button>
                        </div>

                        <!-- Main Display -->
                        <div class="chord-main-display">
                            <div class="canvas-container">
                                <canvas id="chord-box" width="300" height="350"></canvas>
                            </div>

                            <div class="chord-info-panel">
                                <div class="info-card">
                                    <div class="info-label">Notes</div>
                                    <div class="info-value" id="chord-notes">--</div>
                                </div>
                                <div class="info-card">
                                    <div class="info-label">Intervals</div>
                                    <div class="interval-badges" id="chord-intervals">
                                        <!-- Generated -->
                                    </div>
                                    <!-- Practice Component -->
                                    <div class="practice-bar">
                                        <div style="flex:1;">
                                            <div class="info-label">Practice Mode</div>
                                            <div class="timer-display" id="practice-timer">00:00</div>
                                            <!-- v1.1 Mode Select -->
                                            <div style="margin-top:8px; display:flex; gap:8px;">
                                                <label><input type="radio" name="p-mode" value="drill" checked
                                                        onchange="chordApp.setPracticeMode('drill')"> Drill
                                                    (Auto)</label>
                                                <label><input type="radio" name="p-mode" value="switch"
                                                        onchange="chordApp.setPracticeMode('switch')"> Switch
                                                    (Manual)</label>
                                            </div>
                                        </div>
                                        <div
                                            style="display:flex; flex-direction:column; gap:8px; align-items:flex-end;">
                                            <button class="action-btn primary" id="practice-toggle"
                                                onclick="chordApp.togglePractice()">Start</button>
                                            <button class="action-btn hidden" id="practice-next"
                                                onclick="chordApp.switchNext()">Done / Next</button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Fretboard View -->
                            <div class="fretboard-container">
                                <canvas id="fretboard-canvas" width="800" height="150"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- SCALE EXPLORER -->
                <div id="view-scales" class="explorer-view" style="display:none">
                    <div class="chord-explorer-container">
                        <div class="chord-controls">
                            <div class="control-group">
                                <label class="info-label">Root</label>
                                <select id="scale-root" class="tuner-select"></select>
                            </div>
                            <div class="control-group">
                                <label class="info-label">Scale</label>
                                <select id="scale-type" class="tuner-select"></select>
                            </div>
                            <button class="action-btn" id="scale-prev">‚óÄ</button>
                            <span class="info-value" id="scale-pos"
                                style="min-width:100px; text-align:center; color:#fff;">Pattern 1</span>
                            <button class="action-btn" id="scale-next">‚ñ∂</button>
                        </div>

                        <div class="chord-main-display">
                            <div class="canvas-container">
                                <canvas id="scale-fretboard" width="800" height="180"></canvas>
                            </div>

                            <div class="chord-info-panel">
                                <div class="info-card">
                                    <div class="info-label">Notes</div>
                                    <div class="info-value" id="scale-notes">--</div>
                                </div>
                                <div class="info-card">
                                    <div class="info-label">Intervals</div>
                                    <div class="interval-badges" id="scale-intervals"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- THEORY WHEEL -->
                <div id="view-theory" class="explorer-view" style="display:none">
                    <div class="theory-toggles">
                        <button class="action-btn active" id="theory-mode-toggle"
                            onclick="theoryApp.toggleMode()">Major</button>
                        <button class="action-btn" id="theory-enh-toggle" onclick="theoryApp.toggleEnharmonic()">Flat
                            (b)</button>
                    </div>

                    <div class="theory-container">
                        <!-- Left: Wheel -->
                        <div class="wheel-wrap">
                            <svg class="wheel-svg" viewBox="-110 -110 220 220" id="theory-wheel-svg">
                                <!-- Generated by JS -->
                            </svg>
                        </div>

                        <!-- Right: Info -->
                        <div class="theory-info-panel">
                            <div class="info-card">
                                <div class="chord-header" style="margin-bottom:0;">
                                    <div>
                                        <div class="info-label">Selected Key</div>
                                        <div class="info-value" style="font-size:2rem;" id="theory-key-name">C Major
                                        </div>
                                    </div>
                                    <div style="text-align:right;">
                                        <div class="info-label">Relative Minor</div>
                                        <div class="info-value" id="theory-rel-minor">Am</div>
                                    </div>
                                </div>
                            </div>

                            <div class="info-card">
                                <div class="info-label">Scale Notes</div>
                                <div class="info-value" id="theory-scale-notes"
                                    style="font-size:1rem; line-height:1.4;">C D E F G A B</div>
                            </div>

                            <div class="info-card">
                                <div class="info-label">Accidentals</div>
                                <div class="info-value" id="theory-accidentals">0</div>
                            </div>

                            <div class="info-card">
                                <div class="info-label">Diatonic Chords (Click to View)</div>
                                <div class="diatonic-grid" id="theory-chords-grid">
                                    <!-- Generated -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            <section id="ai-lab">
                <header class="section-header">
                    <h1 class="section-title">AI Lab</h1>
                    <p class="section-subtitle">Next-gen features powered by real-time analysis and algorithms.</p>
                </header>

                <!-- AI Sub Nav -->
                <div class="sub-nav">
                    <button class="sub-nav-btn active" onclick="aiLabApp.switchView('chord-id')"
                        data-ai-view="chord-id">Chord ID</button>
                    <button class="sub-nav-btn" onclick="aiLabApp.switchView('tab-gen')" data-ai-view="tab-gen">Tab
                        Gen</button>
                    <button class="sub-nav-btn" onclick="aiLabApp.switchView('progression')"
                        data-ai-view="progression">Progression</button>
                    <button class="sub-nav-btn" onclick="aiLabApp.switchView('scale-rec')"
                        data-ai-view="scale-rec">Scale Rec</button>
                </div>

                <!-- 1. Chord ID View -->
                <div id="ai-view-chord-id" class="ai-view">
                    <div class="theory-container"
                        style="display:flex; flex-direction:column; align-items:center; gap:20px;">

                        <div class="visualizer-container"
                            style="position:relative; width:100%; max-width:600px; height:200px; background:#111; border-radius:12px; overflow:hidden; border:1px solid #333;">
                            <canvas id="ai-visualizer" width="600" height="200"></canvas>
                            <div style="position:absolute; top:10px; left:10px; font-size:12px; color:#666;">AUDIO INPUT
                            </div>
                        </div>

                        <div class="controls">
                            <button class="action-btn" id="ai-mic-toggle" onclick="aiChordFinder.toggleMic()">Start
                                Listening</button>
                        </div>

                        <div class="info-card" style="width:100%; max-width:600px; text-align:center;">
                            <div class="info-label">Detected Chord</div>
                            <div class="info-value" id="ai-chord-result" style="font-size:3rem; color:#00E676;">--</div>
                            <div class="info-label detection-confidence" style="color:#666; margin-top:5px;">Confidence:
                                0%</div>
                        </div>

                        <div class="info-card" style="width:100%; max-width:600px;">
                            <div class="info-label">Alternatives</div>
                            <div class="dia-grid" id="ai-chord-alts"
                                style="display:flex; gap:10px; justify-content:center; margin-top:10px;">
                                <!-- Generated -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 2. Tab Generator View -->
                <div id="ai-view-tab-gen" class="ai-view" style="display:none">
                    <div class="theory-toggles">
                        <input type="text" id="ai-tab-input" class="search-input"
                            placeholder="Enter Chord (e.g. C#m7)..." style="width:200px;">
                        <button class="action-btn" onclick="aiTabGen.generate()">Generate Tab</button>
                    </div>
                    <div id="ai-tab-output" class="tab-scroller"
                        style="margin-top:20px; overflow-x:auto; padding-bottom:20px;">
                        <!-- Generated Canvases will go here -->
                        <div style="text-align:center; color:#666;">Enter a chord to generate playable shapes.</div>
                    </div>
                </div>

                <!-- 3. Progression Generator View -->
                <div id="ai-view-progression" class="ai-view" style="display:none">
                    <div class="chord-controls">
                        <div class="control-group">
                            <label class="info-label">Key</label>
                            <select id="ai-prog-key" class="tuner-select">
                                <option value="C">C</option>
                                <option value="G">G</option>
                                <option value="D">D</option>
                                <option value="A">A</option>
                                <option value="E">E</option>
                                <option value="B">B</option>
                                <option value="F#">F#</option>
                                <option value="Db">Db</option>
                                <option value="Ab">Ab</option>
                                <option value="Eb">Eb</option>
                                <option value="Bb">Bb</option>
                                <option value="F">F</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label class="info-label">Mood</label>
                            <select id="ai-prog-mood" class="tuner-select">
                                <option value="happy">Happy (Pop/Major)</option>
                                <option value="sad">Sad (Minor)</option>
                                <option value="epic">Epic (Film Score)</option>
                                <option value="jazzy">Jazzy (Complex)</option>
                                <option value="dark">Dark (Phrygian)</option>
                            </select>
                        </div>
                        <button class="action-btn" onclick="aiProgressionGen.generate()">Generate</button>
                    </div>

                    <div id="ai-prog-result" style="margin-top:30px; display:flex; flex-direction:column; gap:15px;">
                        <!-- Results -->
                    </div>
                </div>

                <!-- 4. Scale Recommender View -->
                <div id="ai-view-scale-rec" class="ai-view" style="display:none">
                    <div class="theory-toggles">
                        <input type="text" id="ai-scale-input" class="search-input"
                            placeholder="Enter Chord (e.g. Am7)..." style="width:200px;">
                        <button class="action-btn" onclick="aiScaleRec.find()">Find Scales</button>
                    </div>
                    <div id="ai-scale-results" class="card-grid" style="margin-top:20px;">
                        <!-- Scale Cards -->
                    </div>
                </div>
            </section>
            <!-- Practice Section -->
            <section id="practice">
                <header class="section-header">
                    <h1 class="section-title">Practice</h1>
                    <p class="section-subtitle">Structured routines to build speed and accuracy.
                    </p>
                </header>
                <div class="card-grid">
                    <div class="card">
                        <h3>Daily Warmup</h3>
                        <p>15-minute routine to get your fingers moving.</p>
                    </div>
                    <div class="card">
                        <h3>Speed Trainer</h3>
                        <p>Incremental BPM trainer for scales and licks.</p>
                    </div>
                </div>
            </section>
            <!-- Jam Section -->
            <section id="jam">
                <header class="section-header">
                    <h1 class="section-title">Jam Mode</h1>
                    <p class="section-subtitle">Generate custom backing tracks and record your ideas.</p>
                </header>

                <div class="jam-container"
                    style="max-width: 800px; margin: 0 auto; display: flex; flex-direction: column; gap: 20px;">

                    <!-- 1. Control Panel -->
                    <div class="jam-controls-panel card"
                        style="display: flex; flex-wrap: wrap; gap: 15px; align-items: center; justify-content: center;">
                        <div class="control-group">
                            <label class="info-label">Style</label>
                            <select id="jam-style" class="tuner-select" onchange="jamApp.setStyle(this.value)">
                                <option value="rock">Rock</option>
                                <option value="blues">Blues</option>
                                <option value="funk">Funk</option>
                                <option value="jazz">Jazz</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label class="info-label">Key</label>
                            <select id="jam-key" class="tuner-select" onchange="jamApp.setKey(this.value)">
                                <option value="C">C</option>
                                <option value="G">G</option>
                                <option value="D">D</option>
                                <option value="A">A</option>
                                <option value="E">E</option>
                                <option value="F">F</option>
                                <option value="Bb">Bb</option>
                                <option value="Eb">Eb</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label class="info-label">Tempo: <span id="jam-bpm-val"
                                    style="color:var(--accent-primary)">100</span></label>
                            <input type="range" id="jam-tempo" min="60" max="180" value="100"
                                oninput="jamApp.setTempo(this.value)">
                        </div>
                    </div>

                    <!-- 2. Live View (Visualizer) -->
                    <div class="jam-live-view"
                        style="background:#111; border-radius:12px; padding:20px; text-align:center; min-height:150px; display:flex; flex-direction:column; justify-content:center; position:relative; overflow:hidden;">
                        <canvas id="jam-visualizer"
                            style="position:absolute; top:0; left:0; width:100%; height:100%; opacity:0.3; pointer-events:none;"></canvas>

                        <div style="position:relative; z-index:2;">
                            <div class="info-label">Now Playing</div>
                            <div id="jam-chord-display"
                                style="font-size:4rem; font-weight:bold; color:#fff; text-shadow:0 0 10px rgba(0,255,0,0.5);">
                                --</div>
                            <div id="jam-scale-display"
                                style="color:var(--accent-primary); font-size:1.2rem; margin-top:5px;">--</div>
                        </div>

                        <div class="next-chord"
                            style="position:absolute; right:20px; bottom:20px; text-align:right; opacity:0.7;">
                            <div class="info-label" style="font-size:0.8rem;">Next</div>
                            <div id="jam-next-chord" style="font-size:1.5rem; font-weight:bold;">--</div>
                        </div>
                    </div>

                    <!-- 3. Transport Bar -->
                    <div class="jam-transport" style="display:flex; justify-content:center; gap:20px; padding:10px;">
                        <button class="action-btn" id="jam-play-btn" onclick="jamApp.togglePlay()"
                            style="width:120px; font-size:1.2rem;">&#9658; PLAY</button>
                        <button class="action-btn" id="jam-rec-btn" onclick="jamApp.toggleRecord()"
                            style="width:120px; background:#444;">&#9679; REC</button>
                    </div>

                    <!-- 4. Recordings -->
                    <div class="jam-recordings card">
                        <h3>Session Recordings</h3>
                        <div id="jam-recordings-list"
                            style="display:flex; flex-direction:column; gap:10px; margin-top:10px;">
                            <div style="color:#666; font-style:italic;">No recordings yet. Hit REC to start.</div>
                        </div>
                    </div>

                </div>
            </section>
            <!-- Profile Section -->
            <section id="profile">
                <header class="section-header">
                    <h1 class="section-title">Profile</h1>
                    <p class="section-subtitle">Manage your settings and progress.</p>
                </header>
                <div class="card-grid">
                    <div class="card" onclick="appState.reset()">
                        <h3>Reset Settings</h3>
                        <p>Restore default application state.</p>
                    </div>
                </div>
            </section>
        </main>
    </div>
    <script>
        /**
         * Global State Management
         */
        const STATE_KEY = 'ug_app_state';

        const DEFAULT_STATE = {

            activeTab: 'tools',
            activeSectionView: 'dashboard',
            // dashboard or tuner
            bpm: 120,
            tuning: 'EADGBE',
            darkMode: true,
            tuner: {
                instrument: "Guitar",
                tuningName: "Standard",
                instrument: "Guitar",
                tuningName: "Standard",
                mode: "auto"
            }

            ,
            metronome: {
                bpm: 120,
                subdivision: 4,
                accent: true,
                preset: 'default'
            },
            theory: {
                keyIndex: 0,
                mode: 'major'
            },
            ai: {
                activeView: 'chord-id',
                lastChordInput: '',
                lastScaleInput: '',
                lastProgKey: 'C',
                lastProgMood: 'happy'
            }
        }

            ;

        const appState = {
            data: {
                ...DEFAULT_STATE
            }

            ,

            init() {
                try {
                    const stored = localStorage.getItem(STATE_KEY);

                    if (stored) {
                        this.data = {
                            ...DEFAULT_STATE,
                            ...JSON.parse(stored)
                        }

                            ;
                        // Merge nested tuner object if missing (backward compatibility)
                        if (!this.data.tuner) this.data.tuner = DEFAULT_STATE.tuner;
                    }
                }

                catch (e) {
                    console.error('State load failed, resetting:', e);
                    this.reset();
                }

                this.apply();
            }

            ,

            save() {
                try {
                    localStorage.setItem(STATE_KEY, JSON.stringify(this.data));
                }

                catch (e) {
                    console.error('State save failed:', e);
                }
            }

            ,

            setTab(tabId) {
                this.data.activeTab = tabId;

                // If leaving tools, ensure tuner is closed cleanly
                if (tabId !== 'tools') {
                    this.data.activeSectionView = 'dashboard';
                    tunerApp.close(false); // Clean close without changing tab
                }

                this.save();
                uiController.renderTab(tabId);
            }

            ,

            reset() {
                this.data = {
                    ...DEFAULT_STATE
                }

                    ;
                this.save();
                this.apply();
                alert('Settings reset to default.');
            }

            ,

            apply() {
                uiController.renderTab(this.data.activeTab);

                // Restore Tuner View if that was active
                if (this.data.activeTab === 'tools' && this.data.activeSectionView === 'tuner') {
                    tunerApp.open(true); // true = skip state save loop
                }
            }
        }

            ;

        /**
         * Tuner Data & Logic
         */
        const TUNER_DATA = {
            "Guitar": {

                strings: 6,
                tunings: [{
                    name: "Standard", notes: ["E2", "A2", "D3", "G3", "B3", "E4"]
                }

                    ,
                {
                    name: "Drop D", notes: ["D2", "A2", "D3", "G3", "B3", "E4"]
                }

                    ,
                {
                    name: "Half-Step Down", notes: ["Eb2", "Ab2", "Db3", "Gb3", "Bb3", "Eb4"]
                }

                ]
            }

            ,
            "Bass": {

                strings: 4,
                tunings: [{
                    name: "Standard", notes: ["E1", "A1", "D2", "G2"]
                }

                    ,
                {
                    name: "Drop D", notes: ["D1", "A1", "D2", "G2"]
                }

                ]
            }

            ,
            "Ukulele": {

                strings: 4,
                tunings: [{
                    name: "Standard (GCEA)", notes: ["G4", "C4", "E4", "A4"]
                }

                ]
            }

            ,
            "Violin": {

                strings: 4,
                tunings: [{
                    name: "Standard", notes: ["G3", "D4", "A4", "E5"]
                }

                ]
            }
        }

            ;

        const NOTE_STRINGS = ["C",
            "C#",
            "D",
            "D#",
            "E",
            "F",
            "F#",
            "G",
            "G#",
            "A",
            "A#",
            "B"];

        /**
         * Migrated Tuner Engine
         * Source: Pro Guitar Tuner Project
         */
        const tunerEngine = {
            config: {
                bufferSize: 4096,
                confidenceThreshold: 0.9,
                minFreq: 60,
                maxFreq: 1000,
                tunedTolerance: 5,
                stableDuration: 600,
                silenceRMS: 0.015
            },

            audioContext: null,
            analyser: null,
            microphone: null,
            isActive: false,
            currentString: 'AUTO',
            guitarStrings: {
                'E2': { freq: 82.41, min: 70, max: 95 },
                'A2': { freq: 110.00, min: 95, max: 125 },
                'D3': { freq: 146.83, min: 130, max: 165 },
                'G3': { freq: 196.00, min: 175, max: 215 },
                'B3': { freq: 246.94, min: 225, max: 270 },
                'E4': { freq: 329.63, min: 300, max: 360 }
            },

            // NOTE DATA
            NOTE_NAMES: ["C", "C#", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"],

            rafId: null,
            lastFrameTime: 0,
            currentRMS: 0,

            async start() {
                if (this.isActive) return;

                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }

                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 2048;

                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    this.microphone.connect(this.analyser);

                    this.isActive = true;
                    this.lastFrameTime = performance.now();
                    this.updateLoop();

                    // UI Hook
                    const btn = document.getElementById('mic-toggle');
                    if (btn) {
                        btn.innerText = "Stop Tuner";
                        btn.classList.add('active');
                    }
                } catch (e) {
                    console.error("Mic Error:", e);
                    alert("Unable to access microphone. Please allow permissions.");
                    this.isActive = false;
                }
            },

            stop() {
                if (!this.isActive) return;

                if (this.rafId) cancelAnimationFrame(this.rafId);
                if (this.microphone) this.microphone.disconnect();
                if (this.audioContext && this.audioContext.state !== 'closed') {
                    this.audioContext.close();
                }

                this.isActive = false;
                this.audioContext = null;

                // UI Hook
                const btn = document.getElementById('mic-toggle');
                if (btn) {
                    btn.innerText = "Start Tuner";
                    btn.classList.remove('active');
                }

                // Reset Display
                this.onUpdate({ note: null, octave: null, cents: 0 });
            },

            setMode(mode) {
                if (mode === 'auto') {
                    this.currentString = 'AUTO';
                }
                // Manual mode 'target' is set via setTarget
            },

            setTarget(note) {
                this.currentString = note;

                // If note not in known strings (custom), generate it
                if (note !== 'AUTO' && !this.guitarStrings[note]) {
                    const f = this.getNoteFreq(note);
                    // Approx +/- 15% window
                    this.guitarStrings[note] = { freq: f, min: f * 0.85, max: f * 1.15 };
                }
            },

            onUpdate(data) {
                // Connect to App UI
                if (typeof tunerApp !== 'undefined') {
                    tunerApp.updateDisplay(data.note, data.octave, data.cents);
                }
            },

            updateLoop() {
                if (!this.isActive) return;

                const now = performance.now();
                const dt = now - this.lastFrameTime;
                this.lastFrameTime = now;

                const buffer = new Float32Array(this.config.bufferSize);
                this.analyser.getFloatTimeDomainData(buffer);

                // RMS
                let rms = 0;
                for (let i = 0; i < buffer.length; i++) rms += buffer[i] * buffer[i];
                rms = Math.sqrt(rms / buffer.length);
                this.currentRMS = rms;

                const frequency = this.autoCorrelate(buffer, this.audioContext.sampleRate, rms);
                this.processPitch(frequency, dt);

                this.rafId = requestAnimationFrame(() => this.updateLoop());
            },

            processPitch(frequency, dt) {
                if (frequency === -1) {
                    // Silence / Noise Gate
                    if (this.currentRMS < this.config.silenceRMS) {
                        this.onUpdate({ note: null, octave: null, cents: 0 });
                    }
                    return;
                }

                let targetFreq = 0;
                let noteName = "";
                let octave = "";
                let centDiff = 0;
                let isValid = false;

                if (this.currentString === 'AUTO') {
                    const detected = this.detectNote(frequency);
                    if (detected) {
                        targetFreq = detected.freq;
                        noteName = detected.note.replace(/\d/, '');
                        octave = detected.note.slice(-1);
                        centDiff = this.calculateCents(frequency, targetFreq);
                        isValid = true;
                    }
                } else {
                    // Manual Locking
                    const s = this.guitarStrings[this.currentString];
                    if (s) {
                        // Strict Window Check
                        if (frequency >= s.min && frequency <= s.max) {
                            targetFreq = s.freq;
                            noteName = this.currentString.replace(/\d/, '');
                            octave = this.currentString.slice(-1);
                            centDiff = this.calculateCents(frequency, targetFreq);
                            isValid = true;
                        }
                    }
                }

                if (isValid) {
                    this.onUpdate({
                        note: noteName,
                        octave: octave,
                        cents: Math.round(centDiff),
                        frequency: frequency
                    });
                }
            },

            detectNote(freq) {
                let closest = null;
                let minDiff = Infinity;

                for (const [note, data] of Object.entries(this.guitarStrings)) {
                    // Optimization: check range first
                    if (freq >= data.min && freq <= data.max) {
                        return { note, freq: data.freq };
                    }

                    const diff = Math.abs(freq - data.freq);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closest = { note, freq: data.freq };
                    }
                }
                return closest;
            },

            getNoteFreq(noteWithOctave) {
                const match = noteWithOctave.match(/^([A-Ga-g]+#?b?)(\d+)$/);
                if (!match) return 0;
                let note = match[1];
                const octave = parseInt(match[2]);

                const flatToSharp = { "Eb": "D#", "Ab": "G#", "Bb": "A#", "Db": "C#", "Gb": "F#" };
                if (flatToSharp[note]) note = flatToSharp[note];

                const noteIndex = this.NOTE_NAMES.indexOf(note);
                const a4Index = 57; // A4 (Index 57)
                const thisIndex = octave * 12 + noteIndex;
                const diff = thisIndex - a4Index;
                return 440 * Math.pow(2, diff / 12);
            },

            calculateCents(current, target) {
                return 1200 * Math.log2(current / target);
            },

            autoCorrelate(buf, sampleRate, precalcRMS) {
                if (precalcRMS < this.config.silenceRMS) return -1;

                // Windowing (trim silence)
                let r1 = 0;
                let r2 = buf.length - 1;
                const thres = 0.2;

                for (let i = 0; i < buf.length / 2; i++) {
                    if (Math.abs(buf[i]) < thres) { r1 = i; break; }
                }
                for (let i = 1; i < buf.length / 2; i++) {
                    if (Math.abs(buf[buf.length - i]) < thres) { r2 = buf.length - i; break; }
                }

                const buf2 = buf.slice(r1, r2);
                const c = new Array(buf2.length).fill(0);

                // Autocorrelation
                for (let offset = 30; offset < 800; offset++) {
                    let corr = 0;
                    for (let i = 0; i < buf2.length - offset; i++) {
                        corr += buf2[i] * buf2[i + offset];
                    }
                    c[offset] = corr;
                }

                // Peak finding
                let d = 0;
                while (c[d] > c[d + 1]) d++;
                let maxval = -1;
                let maxpos = -1;

                for (let i = d; i < c.length; i++) {
                    if (c[i] > maxval) {
                        maxval = c[i];
                        maxpos = i;
                    }
                }

                let T0 = maxpos;

                // Parabolic Interpolation
                const x1 = c[T0 - 1];
                const x2 = c[T0];
                const x3 = c[T0 + 1];
                const a = (x1 + x3 - 2 * x2) / 2;
                const b = (x3 - x1) / 2;
                if (a) T0 = T0 - b / (2 * a);

                return sampleRate / T0;
            }
        };

        const tunerApp = {
            currentInstrument: "Guitar",
            currentTuning: [],
            mode: "auto",

            open(skipSave = false) {
                // UI Switch
                document.getElementById('tools-dashboard').classList.add('hidden');
                document.getElementById('tuner-view').classList.remove('hidden');

                if (!skipSave) {
                    appState.data.activeSectionView = 'tuner';
                    appState.save();
                }

                this.populateInstruments();
                this.setInstrument(appState.data.tuner.instrument || "Guitar", true);
            }

            ,

            close(saveState = true) {
                tunerEngine.stop();
                document.getElementById('tuner-view').classList.add('hidden');
                document.getElementById('tools-dashboard').classList.remove('hidden');

                if (saveState) {
                    appState.data.activeSectionView = 'dashboard';
                    appState.save();
                }
            }

            ,

            toggleMic() {
                if (tunerEngine.isActive) tunerEngine.stop();
                else tunerEngine.start();
            }

            ,

            toggleMode() {
                this.mode = this.mode === 'auto' ? 'manual' : 'auto';

                document.getElementById('mode-toggle').innerText = `Mode: ${this.mode.charAt(0).toUpperCase() + this.mode.slice(1)
                    }

                `;
                appState.data.tuner.mode = this.mode;
                appState.save();

                tunerEngine.setMode(this.mode);

                if (this.mode === 'auto') {
                    this.renderStrings();
                }
            }

            ,

            populateInstruments() {
                const select = document.getElementById('tuner-instrument');
                select.innerHTML = '';

                Object.keys(TUNER_DATA).forEach(inst => {
                    const opt = document.createElement('option');
                    opt.value = inst;
                    opt.innerText = inst;
                    select.appendChild(opt);
                });
                select.value = appState.data.tuner.instrument;
            }

            ,

            setInstrument(name, forceInit = false) {
                if (!TUNER_DATA[name]) return;
                this.currentInstrument = name;

                // Update State
                appState.data.tuner.instrument = name;
                appState.save();

                // Populate Tunings
                const tuningSelect = document.getElementById('tuner-tuning');
                tuningSelect.innerHTML = '';

                TUNER_DATA[name].tunings.forEach((t, index) => {
                    const opt = document.createElement('option');
                    opt.value = index;
                    opt.innerText = t.name;
                    tuningSelect.appendChild(opt);
                });

                // Default to first tuning or saved
                this.setTuning(0);
            }

            ,

            setTuning(index) {
                const tuningData = TUNER_DATA[this.currentInstrument].tunings[index];
                if (!tuningData) return;

                this.currentTuning = tuningData.notes;
                appState.data.tuner.tuningName = tuningData.name;
                appState.save();

                // Setup Engine targets (pre-calc if needed, though SetTarget handles it on demand)
                this.renderStrings();
            }

            ,

            renderStrings() {
                const container = document.getElementById('string-selector');
                container.innerHTML = '';

                this.currentTuning.forEach((note, idx) => {
                    const btn = document.createElement('div');
                    btn.className = 'string-btn';
                    btn.innerText = note;
                    btn.onclick = () => this.selectString(note, btn);

                    // Check active
                    if (this.mode === 'manual' && tunerEngine.currentString === note) {
                        btn.classList.add('active');
                    }

                    container.appendChild(btn);
                });
            }

            ,

            selectString(note, btnEl) {
                if (this.mode !== 'manual') this.toggleMode();
                tunerEngine.setTarget(note);

                // Update UI
                document.querySelectorAll('.string-btn').forEach(b => b.classList.remove('active'));
                btnEl.classList.add('active');
            }

            ,

            updateDisplay(note, octave, cents) {
                const noteEl = document.getElementById('note-display');
                const needleEl = document.getElementById('tuner-needle');
                const centerEl = document.getElementById('cents-display');

                if (!note) {
                    noteEl.innerHTML = '--';
                    noteEl.className = 'note-name';
                    centerEl.innerText = '0 cents';
                    needleEl.style.left = '50%';
                    needleEl.className = 'needle';
                    return;
                }

                noteEl.innerHTML = `${note
                    }

                <span class="octave">${octave
                    }

                </span>`;

                centerEl.innerText = `${cents > 0 ? '+' : ''
                    }

                ${cents
                    }

                cents`;

                // Calculate visual position
                const clampedCents = Math.max(-50, Math.min(50, cents));
                const percent = 50 + clampedCents;

                needleEl.style.left = `${percent
                    }

                %`;

                // Color States
                needleEl.className = 'needle';
                noteEl.className = 'note-name';

                if (Math.abs(cents) <= 5) {
                    needleEl.classList.add('in-tune');
                    noteEl.classList.add('in-tune');
                }

                else if (cents > 5) {
                    needleEl.classList.add('sharp');
                    noteEl.classList.add('sharp');
                }

                else {
                    needleEl.classList.add('flat');
                    noteEl.classList.add('flat');
                }
            }
        }

            ;

        /**
         * Metronome Engine
         * Uses Web Audio API with Lookahead Scheduling
         */
        const metronomeEngine = {
            audioContext: null,
            nextNoteTime: 0.0,
            timerID: null,
            lookahead: 25.0,
            // ms
            scheduleAheadTime: 0.1,
            // s
            queue: [],
            // For visuals

            // State
            isPlaying: false,
            bpm: 120,
            subdivision: 4,
            // 4 = quarter, 8 = eighth, 12 = triplet
            accent: true,
            beatCount: 0,

            // Current Rhythm Config
            notesPerBeat: 1,

            init() {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContext();
                }

                catch (e) {
                    console.warn('Web Audio API not supported', e);
                }
            }

            ,

            start() {
                if (this.isPlaying) return;
                if (!this.audioContext) this.init();
                if (this.audioContext.state === 'suspended') this.audioContext.resume();

                this.isPlaying = true;
                this.beatCount = 0;
                this.nextNoteTime = this.audioContext.currentTime + 0.1;
                this.scheduler();
            }

            ,

            stop() {
                this.isPlaying = false;
                window.clearTimeout(this.timerID);
            }

            ,

            scheduler() {

                // While there are notes that will play between now and next interval
                while (this.nextNoteTime < this.audioContext.currentTime + this.scheduleAheadTime) {
                    this.scheduleNote(this.beatCount, this.nextNoteTime);
                    this.nextNote(); // Advance time
                }

                if (this.isPlaying) {
                    this.timerID = window.setTimeout(() => this.scheduler(), this.lookahead);
                }
            }

            ,

            scheduleNote(beatNumber, time) {
                if (!this.audioContext) return;

                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();

                osc.connect(gain);
                gain.connect(this.audioContext.destination);

                const maxBeats = this.getMaxBeats();
                // Accent logic: first beat of the bar
                // beatNumber resets every bar (e.g. 0-3 for quarter 4/4)
                const isAccent = (beatNumber % maxBeats === 0) && this.accent;

                // Sound Design
                if (isAccent) {
                    osc.frequency.value = 1000;
                    gain.gain.value = 0.8;
                }

                else if (beatNumber % this.notesPerBeat === 0) {
                    // Main Beat (Non-accent)
                    osc.frequency.value = 800;
                    gain.gain.value = 0.6;
                }

                else {
                    // Subdivision click
                    osc.frequency.value = 600;
                    gain.gain.value = 0.3;
                }

                // Short, percussive envelope
                gain.gain.setValueAtTime(gain.gain.value, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);

                osc.start(time);
                osc.stop(time + 0.05);

                // Queue for Visuals
                this.queue.push({
                    note: beatNumber, time: time, isAccent: isAccent
                });
            }

            ,

            nextNote() {
                // Advance time by a note length
                const secondsPerBeat = 60.0 / this.bpm;

                // Modifier based on subdivision
                // Quarter (4) = 1.0 * secondsPerBeat
                // Eighth (8) = 0.5 * secondsPerBeat
                // Triplet (12) = 0.333 * secondsPerBeat
                let modifier = 1;
                if (this.subdivision == 8) modifier = 0.5;
                if (this.subdivision == 12) modifier = 1 / 3;

                this.nextNoteTime += secondsPerBeat * modifier;

                this.beatCount++;

                /* 
                       We don't necessarily reset beatCount here if we want continuous counting, 
                       but strictly resetting helps keeping accent logic simple: 0 is always accent.
                    */
                if (this.beatCount >= this.getMaxBeats()) {
                    this.beatCount = 0;
                }
            }

            ,

            getMaxBeats() {
                // 4/4 Time Signature baseline
                if (this.subdivision == 4) return 4;
                if (this.subdivision == 8) return 8;
                if (this.subdivision == 12) return 12;
                return 4;
            }

            ,

            // Helper to set config
            setConfig(bpm, sub, accent) {
                this.bpm = bpm;
                this.subdivision = parseInt(sub);
                this.accent = accent;

                if (this.subdivision == 4) this.notesPerBeat = 1;
                if (this.subdivision == 8) this.notesPerBeat = 2;
                if (this.subdivision == 12) this.notesPerBeat = 3;
            }
        }

            ;

        const metronomeApp = {
            tapHistory: [],
            lastTapTime: 0,
            rafId: null,

            open() {
                // Ensure Tuner view is closed properly if switching direct (though UI handles via dashboard)
                tunerApp.close(false);

                document.getElementById('tools-dashboard').classList.add('hidden');
                document.getElementById('metronome-view').classList.remove('hidden');

                appState.data.activeSectionView = 'metronome';
                appState.save();

                // Load State
                const state = appState.data.metronome || {
                    bpm: 120, subdivision: 4, accent: true, preset: 'default'
                }

                    ;
                this.setBPM(state.bpm || 120, false);
                this.setSubdivision(state.subdivision || 4);
                this.setAccent(state.accent !== undefined ? state.accent : true);

                // Preset Select Update
                const presetSel = document.getElementById('metro-preset');
                if (presetSel && state.preset) presetSel.value = state.preset;

                this.updateUI();
                this.animationLoop();
            }

            ,

            close(saveState = true) {
                metronomeEngine.stop();
                cancelAnimationFrame(this.rafId);

                document.getElementById('metronome-view').classList.add('hidden');
                document.getElementById('tools-dashboard').classList.remove('hidden');

                if (saveState) {
                    appState.data.activeSectionView = 'dashboard';
                    appState.save();
                }

                this.updateUI();
            }

            ,

            toggle() {
                if (metronomeEngine.isPlaying) {
                    metronomeEngine.stop();
                }

                else {
                    // Start
                    metronomeEngine.start();
                }

                this.updateUI();
            }

            ,

            setBPM(val, save = true) {
                let bpm = parseInt(val);
                if (isNaN(bpm)) bpm = 120;
                if (bpm < 30) bpm = 30;
                if (bpm > 300) bpm = 300;

                metronomeEngine.bpm = bpm;

                const valEl = document.getElementById('bpm-val');
                const sliderEl = document.getElementById('bpm-slider');
                if (valEl) valEl.innerText = bpm;
                if (sliderEl) sliderEl.value = bpm;

                if (save) {
                    this.saveState({
                        bpm: bpm
                    });
                }
            }

            ,

            adjustBPM(delta) {
                const current = metronomeEngine.bpm;
                this.setBPM(current + delta);
            }

            ,

            tapTempo() {
                const now = performance.now();

                if (now - this.lastTapTime > 2000) {
                    this.tapHistory = [];
                }

                this.lastTapTime = now;
                this.tapHistory.push(now);

                if (this.tapHistory.length > 5) this.tapHistory.shift();

                if (this.tapHistory.length >= 2) {
                    let sum = 0;

                    for (let i = 1; i < this.tapHistory.length; i++) {
                        sum += this.tapHistory[i] - this.tapHistory[i - 1];
                    }

                    const avgMs = sum / (this.tapHistory.length - 1);
                    const bpm = Math.round(60000 / avgMs);
                    this.setBPM(bpm);
                }
            }

            ,

            setSubdivision(val) {
                const sub = parseInt(val);
                metronomeEngine.subdivision = sub;
                metronomeEngine.setConfig(metronomeEngine.bpm, sub, metronomeEngine.accent);

                // UI Update
                const sel = document.getElementById('metro-subdivision');
                if (sel) sel.value = sub;

                this.saveState({
                    subdivision: sub
                });
            }

            ,

            toggleAccent() {
                this.setAccent(!metronomeEngine.accent);
            }

            ,

            setAccent(isOn) {
                metronomeEngine.accent = isOn;
                metronomeEngine.setConfig(metronomeEngine.bpm, metronomeEngine.subdivision, isOn);

                const btn = document.getElementById('metro-accent-toggle');

                if (btn) {
                    btn.innerText = isOn ? "ON" : "OFF";
                    btn.classList.toggle('active', isOn);
                }

                this.saveState({
                    accent: isOn
                });
            }

            ,

            loadPreset(name) {
                let preset = {
                    bpm: 120, subdivision: 4, accent: true
                }

                    ;

                if (name === 'rock') preset = {
                    bpm: 120, subdivision: 4, accent: true
                }

                    ; // 4/4 

                else if (name === 'jazz') preset = {
                    bpm: 130, subdivision: 12, accent: false
                }

                    ; // Swing/Triplet

                this.setBPM(preset.bpm);
                this.setSubdivision(preset.subdivision);
                this.setAccent(preset.accent);

                this.saveState({
                    preset: name
                });
            }

            ,

            saveState(updates) {
                if (!appState.data.metronome) appState.data.metronome = {}

                    ;
                Object.assign(appState.data.metronome, updates);
                appState.save();
            }

            ,

            updateUI() {
                const btn = document.getElementById('metro-toggle');

                if (btn) {
                    if (metronomeEngine.isPlaying) {
                        btn.innerHTML = "&#9632; STOP";
                        btn.classList.add('active'); // CSS can style .active red if needed
                    }

                    else {
                        btn.innerHTML = "&#9658; START";
                        btn.classList.remove('active');
                    }
                }
            }

            ,

            animationLoop() {
                if (document.getElementById('metronome-view').classList.contains('hidden')) return;

                const draw = () => {
                    const ctx = metronomeEngine.audioContext;

                    if (!ctx) {
                        this.rafId = requestAnimationFrame(draw);
                        return;
                    }

                    const currentTime = ctx.currentTime;

                    // Process queue
                    while (metronomeEngine.queue.length && metronomeEngine.queue[0].time < currentTime) {
                        const event = metronomeEngine.queue.shift();

                        // Allow a small window for visual sync, otherwise discard old events
                        if (currentTime - event.time < 0.2) {
                            this.flashBeat(event);
                        }
                    }

                    this.rafId = requestAnimationFrame(draw);
                }

                    ;
                this.rafId = requestAnimationFrame(draw);
            }

            ,

            flashBeat(event) {
                // Determine which dot to flash
                const dots = document.querySelectorAll('.beat-dot');
                if (dots.length === 0) return;

                // Index logic:
                // We want to map note index to 0..3 
                // e.g. 4/4 Quarter: 0,1,2,3 -> 0,1,2,3
                // 4/4 Eighth: 0,1,2,3,4,5,6,7 -> 0,0, 1,1, 2,2, 3,3 ? 
                // OR sequential: 0,1,2,3, 0,1,2,3.
                // Let's go with sequential beat mapping (Measure progress)

                const notesPerBeat = metronomeEngine.notesPerBeat;
                const mainBeat = Math.floor(event.note / notesPerBeat);

                // Reset all first
                dots.forEach(d => {
                    d.classList.remove('active'); d.classList.remove('accent');
                });

                const dot = dots[mainBeat % 4];

                if (dot) {
                    if (event.isAccent) dot.classList.add('accent');
                    else dot.classList.add('active');

                    // Clear after 100ms
                    setTimeout(() => {
                        dot.classList.remove('active');
                        dot.classList.remove('accent');
                    }

                        , 100);
                }
            }
        }

            ;

        /**
         * Global Audio Controller (Modified for Tuner access)
         */
        const audioController = {
            startMic() {
                metronomeApp.close(false); // Stop metronome
                tunerApp.toggleMic();
            }

            ,
            stopMic() {
                tunerEngine.stop();
                metronomeEngine.stop();
            }

            ,
            playSound() {
                console.log('Audio: Playing generic sound');
                alert('Audio Stub: *Beep*');
            }

            ,
            stopSound() {
                console.log('Audio: Sound stopped');
            }

            ,
            setBPM(bpm) {
                // Legacy stub replacement
                metronomeApp.setBPM(bpm);
                metronomeApp.open(); // Auto open if called externally
            }
        }

            ;

        ;

        /**
         * UI Controller
         */
        const uiController = {
            init() {
                // Setup Navigation Listeners
                const navItems = document.querySelectorAll('.nav-item');

                navItems.forEach(item => {
                    item.addEventListener('click', (e) => {
                        // Find closest button in case user clicked icon/span
                        const btn = e.target.closest('.nav-item');
                        const target = btn.dataset.target;

                        if (target) {
                            appState.setTab(target);
                        }
                    });
                });

                // Desktop Header Visibility Logic
                this.handleResize();
                window.addEventListener('resize', () => this.handleResize());
            },

            // New switchLearnView helper
            switchLearnView(viewName) {
                // 1. Buttons
                document.querySelectorAll('.sub-nav-btn').forEach(b => {
                    b.classList.toggle('active', b.dataset.view === viewName);
                });

                // 2. Sections
                document.querySelectorAll('.explorer-view').forEach(v => {
                    v.style.display = (v.id === `view-${viewName}`) ? 'block' : 'none';
                });
            }

            ,

            renderTab(tabId) {

                // 1. Update Buttons
                document.querySelectorAll('.nav-item').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.target === tabId);
                });

                // 2. Update Sections
                const sections = document.querySelectorAll('section');
                let found = false;

                sections.forEach(sec => {
                    if (sec.id === tabId) {
                        sec.classList.add('active');
                        found = true;
                    }

                    else {
                        sec.classList.remove('active');
                    }
                });

                // Error Handling for missing section
                if (!found) {
                    console.warn(`Section #${tabId
                        }

                        not found, falling back to tools.`);
                    if (tabId !== 'tools') appState.setTab('tools');
                }
            }

            ,

            handleResize() {
                const isDesktop = window.innerWidth >= 768;
                const header = document.querySelector('.nav-header');
                if (header) header.style.display = isDesktop ? 'block' : 'none';
            }
        }

            ;

        /**
         * Boot
         */
        /**
         * =========================================
         * CHORD & SCALE SYSTEM LOGIC
         * =========================================
         */
        const SCALE_DATA = {
            TYPES: {
                "Major": { name: "Major", intervals: [0, 2, 4, 5, 7, 9, 11] },
                "Natural Minor": { name: "Natural Minor", intervals: [0, 2, 3, 5, 7, 8, 10] },
                "Pentatonic Major": { name: "Major Pentatonic", intervals: [0, 2, 4, 7, 9] },
                "Pentatonic Minor": { name: "Minor Pentatonic", intervals: [0, 3, 5, 7, 10] },
                "Blues": { name: "Blues", intervals: [0, 3, 5, 6, 7, 10] },
                "Harmonic Minor": { name: "Harmonic Minor", intervals: [0, 2, 3, 5, 7, 8, 11] },
                "Melodic Minor": { name: "Melodic Minor", intervals: [0, 2, 3, 5, 7, 9, 11] }
            },
            // Simple Pattern Ranges for V1 (based on typical CAGED positioning for C Major)
            // Ideally this would be dynamic per Root, but for V1 we just use generic visual blocks
            // or we use a "Relative to Root" system?
            // Let's implement a simple "Fret Window" system for patterns.
            PATTERNS: [
                { name: "Full Neck", min: 0, max: 12 },
                { name: "Pattern 1", min: 0, max: 4 },   // Open position
                { name: "Pattern 2", min: 3, max: 7 },
                { name: "Pattern 3", min: 5, max: 9 },
                { name: "Pattern 4", min: 7, max: 11 },
                { name: "Pattern 5", min: 10, max: 14 }
            ]
        };

        const CHORD_DATA = {
            ROOTS: ["C", "C#", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"],

            // Interval formulas (semitones from root)
            TYPES: {
                "Major": { name: "Major", intervals: [0, 4, 7] },
                "Minor": { name: "Minor", intervals: [0, 3, 7] },
                "7": { name: "Dominant 7", intervals: [0, 4, 7, 10] },
                "Maj7": { name: "Major 7", intervals: [0, 4, 7, 11] },
                "m7": { name: "Minor 7", intervals: [0, 3, 7, 10] },
                "sus2": { name: "Sus2", intervals: [0, 2, 7] },
                "sus4": { name: "Sus4", intervals: [0, 5, 7] },
                "dim": { name: "Diminished", intervals: [0, 3, 6] },
                "aug": { name: "Augmented", intervals: [0, 4, 8] }
            },

            // Movable Shapes (Base definitions)
            // relative: offsets from the Root Note on a specific string
            SHAPES: {
                "Major": [
                    { rootString: 6, offsets: [0, 2, 2, 1, 0, 0] }, // E-shape
                    { rootString: 5, offsets: [-1, 0, 2, 2, 2, 0] }, // A-shape
                    { rootString: 4, offsets: [-1, -1, 0, 2, 3, 2] } // D-shape
                ],
                "Minor": [
                    { rootString: 6, offsets: [0, 2, 2, 0, 0, 0] }, // Em-shape
                    { rootString: 5, offsets: [-1, 0, 2, 2, 1, 0] }, // Am-shape
                    { rootString: 4, offsets: [-1, -1, 0, 2, 3, 1] } // Dm-shape
                ],
                "7": [
                    { rootString: 6, offsets: [0, 2, 0, 1, 0, 0] }, // E7
                    { rootString: 5, offsets: [-1, 0, 2, 0, 2, 0] } // A7
                ],
                "Maj7": [
                    { rootString: 6, offsets: [0, -1, 1, 1, 0, -1] }, // Emaj7ish (Shell) - simpler: 6th string root shell
                    { rootString: 5, offsets: [-1, 0, 2, 1, 2, 0] } // Amaj7
                ],
                "m7": [
                    { rootString: 6, offsets: [0, -1, 0, 0, 0, 0] }, // Em7
                    { rootString: 5, offsets: [-1, 0, 2, 0, 1, 0] } // Am7
                ],
                // Fallbacks can be added or procedurally generated, keeping it simple for V1
                "sus2": [{ rootString: 4, offsets: [-1, -1, 0, 2, 3, 0] }], // Dsus2
                "sus4": [{ rootString: 4, offsets: [-1, -1, 0, 2, 3, 3] }], // Dsus4
                "dim": [{ rootString: 5, offsets: [-1, 0, 1, 2, -1, -1] }], // Adim (roughly)
                "aug": [{ rootString: 6, offsets: [0, -1, 2, 1, 1, -1] }]  // Eaug
            }
        };

        const chordEngine = {
            getNoteName(index) {
                return CHORD_DATA.ROOTS[index % 12];
            },

            getNoteIndex(name) {
                const map = {
                    "C": 0, "C#": 1, "Db": 1, "D": 2, "D#": 3, "Eb": 3,
                    "E": 4, "F": 5, "F#": 6, "Gb": 6, "G": 7, "G#": 8, "Ab": 8,
                    "A": 9, "A#": 10, "Bb": 10, "B": 11
                };
                return map[name];
            },

            // Generate the theoretical notes of the chord
            // Generate the theoretical notes of the chord
            getChordNotes(root, type) {
                const rootIdx = this.getNoteIndex(root);
                const intervals = CHORD_DATA.TYPES[type].intervals;
                return intervals.map(interval => this.getNoteName(rootIdx + interval));
            },

            getIntervalName(semitones) {
                const names = {
                    0: "R", 1: "b2", 2: "2", 3: "b3", 4: "3", 5: "4",
                    6: "b5", 7: "5", 8: "b6", 9: "6", 10: "b7", 11: "7"
                };
                return names[semitones % 12] || "?";
            },

            // Determine fret positions for a given Root + Type
            getPositions(root, type) {
                const positions = [];
                const shapes = CHORD_DATA.SHAPES[type] || CHORD_DATA.SHAPES["Major"]; // Fallback to Major if missing

                const rootVal = this.getNoteIndex(root);

                shapes.forEach(shape => {
                    // Find the fret of the Root Note on the shape's rootString
                    // Standard Tuning: E2 A2 D3 G3 B3 E4
                    // String Indices (0-5): E A D G B E
                    // Base Offsets: E=0, A=5, D=10, G=15, B=19, E=24 (relative to low E)
                    // Let's use simple string open note indices:
                    const stringOpenIndices = [4, 9, 2, 7, 11, 4]; // E A D G B E

                    const openNoteIndex = stringOpenIndices[shape.rootString - 1]; // 1-based string to array

                    // Calculate fret needed to hit the Target Root on this string
                    // target = current + fret
                    // fret = target - current
                    let fretDelta = rootVal - openNoteIndex;
                    if (fretDelta < 0) fretDelta += 12; // Wrap around

                    // Apply this delta to the shape's relative offsets
                    const absoluteFrets = shape.offsets.map(offset => {
                        if (offset === -1) return -1; // Mute stays mute
                        return offset + fretDelta;
                    });

                    // Check playability (e.g. not above fret 15 for now)
                    if (absoluteFrets.some(f => f > 15)) return;

                    positions.push({
                        frets: absoluteFrets,
                        baseFret: Math.min(...absoluteFrets.filter(f => f > 0)) || 1
                    });
                });

                return positions;
            }
        }

        const scaleEngine = {
            getNotes(root, type) {
                // Same logic as chords, different intervals
                const rootIdx = chordEngine.getNoteIndex(root);
                const intervals = SCALE_DATA.TYPES[type].intervals;
                return intervals.map(i => chordEngine.getNoteName(rootIdx + i));
            },

            getIntervals(type) {
                return SCALE_DATA.TYPES[type].intervals;
            }
        };

        const chordRenderer = {
            drawBox(canvas, position) {
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;

                // Clear
                ctx.fillStyle = '#1E1E1E'; // var(--bg-secondary)
                ctx.fillRect(0, 0, w, h);

                const padding = 40;
                const boxW = w - padding * 2;
                const boxH = h - 100;
                const startY = 60;

                // Determine Fret Range
                // If baseFret is high (e.g. 5), we show frets 5-9.
                // If baseFret is 1, we show 1-5 (and draw nut).
                let startFret = position.baseFret;
                if (startFret === 0) startFret = 1;

                // Logic: If the chord has open strings (0), typically we show from fret 1.
                // If lowest fingered fret is 5, we show 5.
                const minFingered = Math.min(...position.frets.filter(f => f > 0));
                // If min fingered is > 0, we generally want that to be the top (or top-1)
                // But simplified: 
                const renderStartFret = (minFingered > 3) ? minFingered : 1;

                // Draw Strings (Vertical)
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 2;
                for (let i = 0; i < 6; i++) {
                    const x = padding + (i * (boxW / 5));
                    ctx.beginPath();
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, startY + boxH);
                    ctx.stroke();
                }

                // Draw Frets (Horizontal)
                const numFrets = 5;
                for (let i = 0; i <= numFrets; i++) {
                    const y = startY + (i * (boxH / numFrets));
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(padding + boxW, y);
                    ctx.stroke();
                }

                // Draw Nut (if startFret == 1)
                if (renderStartFret === 1) {
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.moveTo(padding, startY);
                    ctx.lineTo(padding + boxW, startY);
                    ctx.stroke();
                }

                // Draw Dots & Indicators (X/O)
                position.frets.forEach((fret, stringIdx) => {
                    const x = padding + (stringIdx * (boxW / 5)); // Low E is index 0 here? 
                    // Let's standard: String 6 (E) is usually Left in diagrams.
                    // My arrays are [E, A, D, G, B, E]. Index 0 i S6. Correct.

                    if (fret === -1) {
                        // Draw X
                        ctx.fillStyle = '#FF5252';
                        ctx.font = '20px Outfit';
                        ctx.fillText('‚úï', x - 6, startY - 10);
                    } else if (fret === 0) {
                        // Draw O
                        ctx.fillStyle = '#fff';
                        ctx.font = '20px Outfit';
                        ctx.fillText('‚óã', x - 6, startY - 10);
                    } else {
                        // Draw Dot
                        // Calculate relative fret position
                        const relFret = fret - renderStartFret + 1;
                        if (relFret >= 1 && relFret <= 5) {
                            const y = startY + ((relFret - 0.5) * (boxH / numFrets));

                            ctx.fillStyle = '#00E676';
                            ctx.beginPath();
                            ctx.arc(x, y, 12, 0, Math.PI * 2);
                            ctx.fill();

                            // Finger hint (optional, skipped for now)
                        }
                    }
                });

                // Draw Fret Number Label
                if (renderStartFret > 0) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '24px Outfit';
                    // v1.1 Fix: Anchor Top Left
                    ctx.fillText(renderStartFret + 'fr', padding - 35, startY + 40);
                }
            },

            drawFretboard(canvas, chordNotes, options = {}) {
                // Options: { startFret: 0, endFret: 12, highlightRoot: true }
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;

                const startFret = options.startFret || 0;
                const endFret = options.endFret || 12;
                const fretCount = endFret - startFret + 1; // e.g. 0-12 = 13 slots

                // Background
                ctx.fillStyle = '#1A1A1A'; // Darker wood
                ctx.fillRect(0, 0, w, h);

                const fretW = w / fretCount;
                const stringH = h / 6;

                // Frets
                ctx.strokeStyle = '#555';
                for (let i = 0; i < fretCount; i++) {
                    const actualFret = startFret + i;
                    // Don't draw line for Nut if startFret is 0 (handled differently or implicit left edge)
                    if (actualFret > 0) {
                        const x = i * fretW;
                        // For Nut (0), usually we draw a Thick line at x=0? 
                        // If startFret=0, index 0 is the "Nut Area". The line for Fret 1 is at index 1 * fretW.
                        // Wait, index i is the space BEFORE fret i+1?
                        // Let's stick to standard: The vertical line IS the fret wire.
                        // Fret 1 wire is at x = 1 * fretW.
                    }

                    const x = (i + 1) * fretW; // Fret Wire
                    if (i < fretCount - 1) { // Don't draw last edge?
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, h);
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }

                // Draw Nut if visible
                if (startFret === 0) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(0, 0, 8, h); // Nut
                }

                // Strings
                const stringColors = ['#e6c181', '#a8d8ea', '#aaeea', '#e6c181', '#a8d8ea', '#e6c181']; // Just styling
                for (let i = 0; i < 6; i++) {
                    const y = (i * stringH) + (stringH / 2);
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 1 + (i * 0.5); // Thicker low strings
                    ctx.stroke();
                }

                // Inlays
                const inlays = [3, 5, 7, 9, 12];
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                inlays.forEach(f => {
                    const x = (f * fretW) - (fretW / 2);
                    ctx.beginPath();
                    ctx.arc(x, h / 2, 6, 0, Math.PI * 2);
                    ctx.fill();
                    if (f === 12) {
                        ctx.beginPath();
                        ctx.arc(x + 15, h / 2, 6, 0, Math.PI * 2); // Double dot? simple is fine
                        ctx.fill();
                    }
                });

                // Highlight Notes
                // Brute force: check every string/fret
                const stringOpens = [4, 9, 2, 7, 11, 4]; // E A D G B E

                for (let s = 0; s < 6; s++) {
                    // Strings are E2...E4
                    for (let i = 0; i < fretCount; i++) {
                        const actualFret = startFret + i;
                        const noteVal = stringOpens[s] + actualFret;
                        const noteName = chordEngine.getNoteName(noteVal);

                        // Check if this note is in our chord
                        if (chordNotes.includes(noteName)) {
                            // Centered in the fret slot
                            // Slot x range: i*fretW to (i+1)*fretW
                            // Center: (i + 0.5) * fretW

                            // Nut Adjustment: if startFret=0 and actualFret=0, it's just left of Fret 1 wire.
                            // Logic works fine.

                            const x = (i + 0.5) * fretW;

                            const y = ((5 - s) * stringH) + (stringH / 2); // Reverse string order for visual (Top is E4 usually? No, Top is E2 in tabs. Fretboard Top is E4/High E)
                            // Standard Fretboard view: High E on top.
                            // My loops: s=0 is E2 (Low).
                            // Screen Y: 0 is top.
                            // So s=0 should be Bottom (Height). layout: 5 is High E.
                            const visualY = ((5 - s) * stringH) + (stringH / 2);

                            // v1.1 Highlight Root
                            const isRoot = (noteName === chordNotes[0]);

                            ctx.beginPath();
                            ctx.arc(x, visualY, 10, 0, Math.PI * 2);

                            if (isRoot) {
                                ctx.fillStyle = '#FFAB40'; // v1.1 Root Orange
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = '#FFAB40';
                            } else {
                                ctx.fillStyle = '#00E676'; // Normal Green
                                ctx.shadowBlur = 0;
                            }

                            ctx.fill();
                            ctx.shadowBlur = 0; // Reset

                            // Text
                            ctx.fillStyle = isRoot ? '#000' : '#000';
                            ctx.font = '700 10px Outfit';
                            ctx.textAlign = 'center';
                            ctx.fillText(noteName, x, visualY + 3);
                        }
                    }
                }

                // Range Label
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '16px Outfit';
                ctx.textAlign = 'right';
                // ctx.fillText(`Frets ${startFret}-${endFret}`, w - 10, h - 10);
            }
        };

        const scaleApp = {
            root: "C",
            type: "Major",
            patternIndex: 0,

            init() {
                const rootSel = document.getElementById("scale-root");
                const typeSel = document.getElementById("scale-type");

                if (!rootSel || !typeSel) return;

                CHORD_DATA.ROOTS.forEach(r => {
                    const o = document.createElement("option");
                    o.value = r; o.textContent = r;
                    rootSel.appendChild(o);
                });

                Object.keys(SCALE_DATA.TYPES).forEach(t => {
                    const o = document.createElement("option");
                    o.value = t; o.textContent = t;
                    typeSel.appendChild(o);
                });

                rootSel.value = this.root;
                typeSel.value = this.type;

                rootSel.onchange = e => { this.root = e.target.value; this.render(); };
                typeSel.onchange = e => { this.type = e.target.value; this.render(); };

                document.getElementById("scale-prev").onclick = () => this.shift(-1);
                document.getElementById("scale-next").onclick = () => this.shift(1);

                this.render();
            },

            shift(dir) {
                const max = SCALE_DATA.PATTERNS.length;
                this.patternIndex = (this.patternIndex + dir + max) % max;
                this.render();
            },

            render() {
                const scale = SCALE_DATA.TYPES[this.type];
                const rootIndex = CHORD_DATA.ROOTS.indexOf(this.root);
                const notes = scale.intervals.map(i =>
                    CHORD_DATA.ROOTS[(rootIndex + i) % 12]
                );

                document.getElementById("scale-notes").innerText = notes.join(" - ");
                document.getElementById("scale-pos").innerText =
                    SCALE_DATA.PATTERNS[this.patternIndex].name;

                const badges = document.getElementById("scale-intervals");
                badges.innerHTML = "";
                scale.intervals.forEach(i => {
                    const b = document.createElement("span");
                    b.className = "badge";
                    b.textContent = i;
                    badges.appendChild(b);
                });

                this.drawFretboard(notes);
            },

            drawFretboard(notes) {
                const canvas = document.getElementById("scale-fretboard");
                if (!canvas) return;
                const ctx = canvas.getContext("2d");
                ctx.clearRect(0, 0, 800, 180);

                // BG
                ctx.fillStyle = "#222";
                ctx.fillRect(0, 0, 800, 180);

                const strings = ["E", "A", "D", "G", "B", "E"];
                const frets = 12;
                const w = 800 / (frets + 1);
                const h = 180 / strings.length;

                // Grid
                ctx.strokeStyle = "#444";
                for (let i = 1; i <= frets; i++) {
                    ctx.beginPath(); ctx.moveTo(i * w, 0); ctx.lineTo(i * w, 180); ctx.stroke();
                }
                strings.forEach((s, i) => {
                    ctx.beginPath(); ctx.moveTo(0, i * h + h / 2); ctx.lineTo(800, i * h + h / 2); ctx.stroke();
                });

                // Notes
                const pattern = SCALE_DATA.PATTERNS[this.patternIndex];
                const startFret = pattern.min;
                const endFret = pattern.max;

                strings.forEach((s, si) => { // s=string name, si=string index (0=Bottom visual?)
                    // My array is [E, A, D, G, B, E]. 0=Low E.
                    // In canvas, 0 is top.
                    // If we want standard view, Top is High E.
                    // So we should iterate reverse or map si to visual y carefully.
                    // User code: si loops 0..5. h*si.
                    // "E" at index 0 (Low E) -> 0 * h -> Top?
                    // Standard tuning array is usually Low to High.
                    // If si=0 is Low E and y=0 is Top, then Low E is at Top (upside down).
                    // Let's invert si for Y.

                    const y = (5 - si) * h + h / 2; // High E on top

                    for (let f = 0; f <= frets; f++) {
                        if (f < startFret || f > endFret) continue; // Pattern masking
                        if (f === 0 && startFret > 0) continue; // Hide open strings if looking up neck? Optional.

                        const note = CHORD_DATA.ROOTS[
                            (CHORD_DATA.ROOTS.indexOf(s) + f) % 12
                        ];
                        if (notes.includes(note)) {
                            ctx.beginPath();
                            ctx.fillStyle = note === this.root ? "#FFAB40" : "#00E676";
                            ctx.arc(w * f + w / 2, y, 10, 0, Math.PI * 2);
                            ctx.fill();

                            // Text
                            ctx.fillStyle = "#000";
                            ctx.font = "10px monospace";
                            ctx.textAlign = "center";
                            ctx.fillText(note, w * f + w / 2, y + 3);
                        }
                    }
                });
            }
        };

        const chordApp = {
            currentRoot: "C",
            currentType: "Major",
            currentPosIndex: 0,
            positions: [],

            // Practice State
            practiceActive: false,
            practiceMode: 'drill', // drill | switch
            timer: null,
            timerSecs: 0,
            switchTarget: null,
            stats: { total: 0, correct: 0 },

            init() {
                this.populateSelectors();

                // Load state
                const saved = appState.data.chord || {};
                if (saved.root) this.currentRoot = saved.root;
                if (saved.type) this.currentType = saved.type;

                this.updateChord();
            },

            populateSelectors() {
                const rSel = document.getElementById('chord-root');
                const tSel = document.getElementById('chord-type');
                if (!rSel || !tSel) return;

                CHORD_DATA.ROOTS.forEach(r => {
                    const opt = document.createElement('option');
                    opt.value = r; opt.innerText = r;
                    rSel.appendChild(opt);
                });

                Object.keys(CHORD_DATA.TYPES).forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t; opt.innerText = CHORD_DATA.TYPES[t].name;
                    tSel.appendChild(opt);
                });

                rSel.value = this.currentRoot;
                tSel.value = this.currentType;
            },

            setRoot(val) {
                this.currentRoot = val;
                this.currentPosIndex = 0;
                this.save();
                this.updateChord();
            },

            setType(val) {
                this.currentType = val;
                this.currentPosIndex = 0;
                this.save();
                this.updateChord();
            },

            save() {
                appState.data.chord = {
                    root: this.currentRoot,
                    type: this.currentType
                };
                appState.save();
            },

            nextPosition() {
                if (this.currentPosIndex < this.positions.length - 1) {
                    this.currentPosIndex++;
                    this.renderData();
                }
            },

            prevPosition() {
                if (this.currentPosIndex > 0) {
                    this.currentPosIndex--;
                    this.renderData();
                }
            },

            updateChord() {
                // 1. Get Positions
                this.positions = chordEngine.getPositions(this.currentRoot, this.currentType);
                if (this.positions.length === 0) {
                    alert('No positions found for this chord type yet!');
                    return;
                }

                this.renderData();
            },

            renderData() {
                const pos = this.positions[this.currentPosIndex];
                const notes = chordEngine.getChordNotes(this.currentRoot, this.currentType);

                // Render Canvas
                const boxCanvas = document.getElementById('chord-box');
                const boardCanvas = document.getElementById('fretboard-canvas');

                if (boxCanvas) chordRenderer.drawBox(boxCanvas, pos);
                if (boardCanvas) chordRenderer.drawFretboard(boardCanvas, notes);

                // Info
                const notesEl = document.getElementById('chord-notes');
                const intervalsEl = document.getElementById('chord-intervals');
                const posEl = document.getElementById('position-indicator');

                if (notesEl) notesEl.innerText = notes.join(' - ');
                if (posEl) posEl.innerText = `Pos ${this.currentPosIndex + 1}/${this.positions.length}`;

                if (intervalsEl) {
                    intervalsEl.innerHTML = '';
                    const intervals = CHORD_DATA.TYPES[this.currentType].intervals;
                    intervals.forEach(i => {
                        const span = document.createElement('span');
                        span.className = 'badge';
                        span.innerText = chordEngine.getIntervalName(i);
                        intervalsEl.appendChild(span);
                    });
                }
            },

            handleSearch(query) {
                if (!query) return;

                // Parser Logic
                // 1. Extract Root
                const rootMatch = query.match(/^([A-Ga-g][#b]?)/);
                if (!rootMatch) return;

                let root = rootMatch[1];
                // Capitalize first letter
                root = root.charAt(0).toUpperCase() + root.slice(1);

                if (!CHORD_DATA.ROOTS.includes(root)) return;

                // 2. Extract Remainder (Type)
                let typeStr = query.substring(root.length).trim().toLowerCase();

                // Map common aliases
                const typeMap = {
                    "": "Major", "maj": "Major", "m": "Minor", "min": "Minor", "-": "Minor",
                    "7": "7", "dom7": "7",
                    "maj7": "Maj7", "m7": "m7", "min7": "m7",
                    "sus2": "sus2", "sus4": "sus4",
                    "dim": "dim", "aug": "aug", "+": "aug"
                };

                // Allow fuzzy search? simple map first
                let matchedType = "Major"; // Default

                // Check map
                if (typeMap[typeStr]) matchedType = typeMap[typeStr];

                // Also check if typeStr matches keys
                Object.keys(CHORD_DATA.TYPES).forEach(k => {
                    if (k.toLowerCase() === typeStr) matchedType = k;
                });

                // Apply
                this.currentRoot = root;
                this.currentType = matchedType;
                this.currentPosIndex = 0;

                // UI Sync
                document.getElementById('chord-root').value = this.currentRoot;
                document.getElementById('chord-type').value = this.currentType;

                this.save();
                this.updateChord();
            },

            setPracticeMode(mode) {
                this.practiceMode = mode;
                // If active, restart with new mode?
                if (this.practiceActive) {
                    this.togglePractice(); // Stop
                    this.togglePractice(); // Start
                }
            },

            togglePractice() {
                this.practiceActive = !this.practiceActive;
                const btn = document.getElementById('practice-toggle');
                const nextBtn = document.getElementById('practice-next');
                const pBox = document.querySelector('.practice-bar');

                if (this.practiceActive) {
                    btn.innerText = "Stop";
                    btn.classList.add('active');
                    pBox.style.borderColor = '#FF5252';

                    this.stats = { total: 0, correct: 0 };

                    if (this.practiceMode === 'switch') {
                        nextBtn.classList.remove('hidden');
                        this.startSwitch();
                    } else {
                        nextBtn.classList.add('hidden');
                        this.startDrill();
                    }

                } else {
                    btn.innerText = "Start Practice";
                    btn.classList.remove('active');
                    pBox.style.borderColor = '#00E676';
                    nextBtn.classList.add('hidden');
                    this.stopTimer();
                }
            },

            startDrill() {
                this.timerSecs = 0;
                const lcd = document.getElementById('practice-timer');
                lcd.innerText = "00:00";

                this.randomize(); // Start with new

                this.timer = setInterval(() => {
                    this.timerSecs++;
                    this.updateTimerDisplay();

                    // Drill: every 5s
                    if (this.timerSecs % 5 === 0) {
                        this.randomize();
                        this.stats.total++;
                    }
                }, 1000);
            },

            startSwitch() {
                this.timerSecs = 0;
                this.updateTimerDisplay();
                this.randomize();

                this.timer = setInterval(() => {
                    this.timerSecs++;
                    this.updateTimerDisplay();
                }, 1000);
            },

            switchNext() {
                // User pressed Done
                this.stats.total++;
                this.stats.correct++; // Assume correct in manual mode

                // Log time? 
                // Reset timer for lap? Or keep running total? 
                // Let's keep running total but randomize chord
                this.randomize();
            },

            updateTimerDisplay() {
                const m = Math.floor(this.timerSecs / 60).toString().padStart(2, '0');
                const s = (this.timerSecs % 60).toString().padStart(2, '0');
                document.getElementById('practice-timer').innerText = `${m}:${s}`;
            },

            stopTimer() {
                clearInterval(this.timer);
            },

            randomize() {
                const r = CHORD_DATA.ROOTS[Math.floor(Math.random() * CHORD_DATA.ROOTS.length)];
                const types = Object.keys(CHORD_DATA.TYPES);
                const t = types[Math.floor(Math.random() * types.length)];

                this.currentRoot = r;
                this.currentType = t;
                this.currentPosIndex = 0;

                // Update UI selects
                document.getElementById('chord-root').value = r;
                document.getElementById('chord-type').value = t;

                this.updateChord();
            }
        };

        const CIRCLE_KEYS = [
            { key: "C", acc: 0, rel: "Am", chords: ["C", "Dm", "Em", "F", "G", "Am", "Bdim"], scale: ["C", "D", "E", "F", "G", "A", "B"] },
            { key: "G", acc: 1, rel: "Em", chords: ["G", "Am", "Bm", "C", "D", "Em", "F#dim"], scale: ["G", "A", "B", "C", "D", "E", "F#"] },
            { key: "D", acc: 2, rel: "Bm", chords: ["D", "Em", "F#m", "G", "A", "Bm", "C#dim"], scale: ["D", "E", "F#", "G", "A", "B", "C#"] },
            { key: "A", acc: 3, rel: "F#m", chords: ["A", "Bm", "C#m", "D", "E", "F#m", "G#dim"], scale: ["A", "B", "C#", "D", "E", "F#", "G#"] },
            { key: "E", acc: 4, rel: "C#m", chords: ["E", "F#m", "G#m", "A", "B", "C#m", "D#dim"], scale: ["E", "F#", "G#", "A", "B", "C#", "D#"] },
            { key: "B", acc: 5, rel: "G#m", chords: ["B", "C#m", "D#m", "E", "F#", "G#m", "A#dim"], scale: ["B", "C#", "D#", "E", "F#", "G#", "A#"] },
            { key: "F#", acc: 6, rel: "D#m", chords: ["F#", "G#m", "A#m", "B", "C#", "D#m", "E#dim"], scale: ["F#", "G#", "A#", "B", "C#", "D#", "E#"] },
            { key: "Db", acc: -5, rel: "Bbm", chords: ["Db", "Ebm", "Fm", "Gb", "Ab", "Bbm", "Cdim"], scale: ["Db", "Eb", "F", "Gb", "Ab", "Bb", "C"] },
            { key: "Ab", acc: -4, rel: "Fm", chords: ["Ab", "Bbm", "Cm", "Db", "Eb", "Fm", "Gdim"], scale: ["Ab", "Bb", "C", "Db", "Eb", "F", "G"] },
            { key: "Eb", acc: -3, rel: "Cm", chords: ["Eb", "Fm", "Gm", "Ab", "Bb", "Cm", "Ddim"], scale: ["Eb", "F", "G", "Ab", "Bb", "C", "D"] },
            { key: "Bb", acc: -2, rel: "Gm", chords: ["Bb", "Cm", "Dm", "Eb", "F", "Gm", "Adim"], scale: ["Bb", "C", "D", "Eb", "F", "G", "A"] },
            { key: "F", acc: -1, rel: "Dm", chords: ["F", "Gm", "Am", "Bb", "C", "Dm", "Edim"], scale: ["F", "G", "A", "Bb", "C", "D", "E"] }
        ];

        const aiLabApp = {
            activeView: 'chord-id',

            init() {
                // Load State
                const s = appState.data.ai || {};
                this.activeView = s.activeView || 'chord-id';

                // Restoring Inputs
                if (s.lastTabInput) document.getElementById('ai-tab-input').value = s.lastTabInput;
                if (s.lastScaleInput) document.getElementById('ai-scale-input').value = s.lastScaleInput;
                if (s.lastProgKey) document.getElementById('ai-prog-key').value = s.lastProgKey;
                if (s.lastProgMood) document.getElementById('ai-prog-mood').value = s.lastProgMood;

                // Open correct view
                this.switchView(this.activeView, false);
            },

            switchView(viewId, save = true) {
                this.activeView = viewId;

                // Update Buttons
                document.querySelectorAll('.sub-nav-btn[data-ai-view]').forEach(b => {
                    b.classList.toggle('active', b.dataset.aiView === viewId);
                });

                // Update Sections
                document.querySelectorAll('.ai-view').forEach(v => {
                    v.style.display = (v.id === `ai-view-${viewId}`) ? 'block' : 'none';
                    if (v.id === `ai-view-${viewId}`) v.classList.add('active');
                });

                // Stop Mic if leaving chord-id
                if (viewId !== 'chord-id') {
                    aiChordFinder.stop();
                }

                if (save) {
                    if (!appState.data.ai) appState.data.ai = {};
                    appState.data.ai.activeView = viewId;
                    appState.save();
                }
            }
        };

        const aiChordFinder = {
            isActive: false,
            audioCtx: null,
            analyser: null,
            rafId: null,
            frequencies: [],

            async start() {
                try {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioCtx.createAnalyser();
                    this.analyser.fftSize = 4096; // High res

                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const src = this.audioCtx.createMediaStreamSource(stream);
                    src.connect(this.analyser);

                    this.isActive = true;
                    this.loop();

                    document.getElementById('ai-mic-toggle').textContent = "Stop Listening";
                    document.getElementById('ai-mic-toggle').classList.add('active');
                } catch (e) {
                    console.error(e);
                    alert("Mic access denied");
                }
            },

            stop() {
                if (!this.isActive) return;
                this.isActive = false;
                if (this.rafId) cancelAnimationFrame(this.rafId);
                if (this.audioCtx) this.audioCtx.close();

                document.getElementById('ai-mic-toggle').textContent = "Start Listening";
                document.getElementById('ai-mic-toggle').classList.remove('active');
            },

            toggleMic() {
                if (this.isActive) this.stop();
                else this.start();
            },

            loop() {
                if (!this.isActive) return;

                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                this.analyser.getByteFrequencyData(dataArray);

                this.drawVisualizer(dataArray);
                this.detectChord(dataArray);

                this.rafId = requestAnimationFrame(() => this.loop());
            },

            drawVisualizer(data) {
                const canvas = document.getElementById('ai-visualizer');
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;

                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, w, h);

                const barWidth = (w / data.length) * 2.5;
                let x = 0;

                for (let i = 0; i < data.length; i++) {
                    const barHeight = data[i] / 255 * h;
                    ctx.fillStyle = `hsl(${i / data.length * 360}, 100%, 50%)`;
                    ctx.fillRect(x, h - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            },

            detectChord(data) {
                // 1. Find Peaks (Simplistic)
                const peaks = [];
                const threshold = 100; // Noise gate

                for (let i = 1; i < data.length - 1; i++) {
                    if (data[i] > threshold && data[i] > data[i - 1] && data[i] > data[i + 1]) {
                        // Frequency = i * sampleRate / fftSize
                        const freq = i * this.audioCtx.sampleRate / this.analyser.fftSize;
                        peaks.push({ freq, amp: data[i] });
                    }
                }

                if (peaks.length === 0) return;

                // 2. Map frequencies to Notes
                const detectedNotes = new Set();
                peaks.sort((a, b) => b.amp - a.amp).slice(0, 5).forEach(p => {
                    const n = tunerEngine.detectNote(p.freq); // Reuse tuner logic
                    if (n) detectedNotes.add(n.note.replace(/[0-9]/g, ''));
                });

                const notes = Array.from(detectedNotes);
                if (notes.length < 2) return; // Need at least 2 notes

                // 3. Match against basic intervals
                // This is a naive check for Demo
                // Sort notes? No, we check permutations or just root?
                // Let's brute force match against known Chords in CHORD_DATA (generated)

                // Simplified matching logic for now
                // We will guess based on note presence
                this.matchChord(notes);
            },

            matchChord(notes) {
                // Brute-force match score
                // Score = (notes_in_chord / total_chord_notes) * (notes_in_input / total_input_notes)

                let bestMatch = null;
                let bestScore = 0;

                // check all roots and types
                CHORD_DATA.ROOTS.forEach(root => {
                    Object.keys(CHORD_DATA.TYPES).forEach(type => {
                        const targetNotes = chordEngine.getChordNotes(root, type);

                        // Intersection
                        const intersection = notes.filter(n => targetNotes.includes(n));

                        // Score calculation
                        const matchRate = intersection.length / targetNotes.length;
                        const noiseRate = 1 - ((notes.length - intersection.length) / notes.length);

                        // Adjust score for strictness
                        const score = matchRate * 0.7 + noiseRate * 0.3;

                        if (score > bestScore && intersection.length >= 2) {
                            bestScore = score;
                            bestMatch = `${root} ${CHORD_DATA.TYPES[type].name}`;
                        }
                    });
                });

                const resEl = document.getElementById('ai-chord-result');
                const confEl = document.querySelector('.detection-confidence');

                if (bestMatch && bestScore > 0.6) {
                    resEl.innerText = bestMatch;
                    confEl.innerText = `Confidence: ${Math.round(bestScore * 100)}%`;
                }
            }
        };

        const aiTabGen = {
            generate() {
                const input = document.getElementById('ai-tab-input').value;
                if (!input) return;

                // Save state
                if (!appState.data.ai) appState.data.ai = {};
                appState.data.ai.lastTabInput = input;
                appState.save();

                // Parse
                // Reuse chordApp.handleSearch logic partly? 
                // Let's assume standard format for now: "Cm7"
                // We need to parse Root + Type

                // Mock parse (basic)
                const rootMatch = input.match(/^([A-Ga-g][#b]?)/);
                if (!rootMatch) { alert("Invalid Chord"); return; }

                let root = rootMatch[1];
                root = root.charAt(0).toUpperCase() + root.slice(1);

                let typeRaw = input.substring(root.length).trim();
                // Map typeRaw to our types
                // Reuse chordApp map if exposed? It's inside handleSearch. 
                // Let's recreate a mini map or expose it. 
                // For safety, just strip major/minor checks
                let type = "Major";
                if (typeRaw.includes("m") || typeRaw.includes("min")) type = "Minor";
                if (typeRaw.includes("7")) type = (type === "Minor") ? "m7" : "7"; // Simplicity
                if (typeRaw.includes("maj7")) type = "Maj7";

                // Generate Positions
                const positions = chordEngine.getPositions(root, type);

                const out = document.getElementById('ai-tab-output');
                out.innerHTML = '';

                if (positions.length === 0) {
                    out.innerHTML = '<div style="padding:20px;">No positions found. Try a simpler chord like C, Am, G7.</div>';
                    return;
                }

                positions.forEach((pos, idx) => {
                    const card = document.createElement('div');
                    card.className = 'tab-card';
                    card.innerHTML = `<div>Position ${idx + 1}</div>`;

                    const canvas = document.createElement('canvas');
                    canvas.width = 200;
                    canvas.height = 240;
                    card.appendChild(canvas);

                    // Render
                    chordRenderer.drawBox(canvas, pos);

                    out.appendChild(card);
                });
            }
        };

        const aiProgressionGen = {
            generate() {
                const key = document.getElementById('ai-prog-key').value;
                const mood = document.getElementById('ai-prog-mood').value;

                // Save
                if (!appState.data.ai) appState.data.ai = {};
                appState.data.ai.lastProgKey = key;
                appState.data.ai.lastProgMood = mood;
                appState.save();

                const out = document.getElementById('ai-prog-result');
                out.innerHTML = '';

                // Logic
                let progs = [];

                if (mood === 'happy') {
                    // I IV V I
                    progs.push(["I", "IV", "V", "I"]);
                    progs.push(["I", "vi", "IV", "V"]); // 50s
                    progs.push(["I", "V", "vi", "IV"]); // Axis
                } else if (mood === 'sad') {
                    // i iv v i
                    // Need minor key calculation?
                    // We can reuse Theory Wheel Key logic!
                    progs.push(["i", "iv", "v", "i"]);
                    progs.push(["i", "VI", "III", "VII"]);
                    progs.push(["i", "iv", "VI", "v"]);
                } else if (mood === 'epic') {
                    progs.push(["i", "VI", "III", "VII"]); // Hans Zimmer-ish
                    progs.push(["VI", "VII", "i", "i"]);
                } else if (mood === 'jazzy') {
                    progs.push(["ii7", "V7", "Imaj7", "I6"]);
                    progs.push(["Imaj7", "vi7", "ii7", "V7"]);
                } else if (mood === 'dark') {
                    progs.push(["i", "bII", "i", "vii¬∞"]); // Phrygian?
                }

                // Render
                progs.forEach(prog => {
                    const card = document.createElement('div');
                    card.className = 'progression-card';

                    // Convert Numerals to Chords
                    // We need a helper to get chords from Key + Numeral
                    // Using CIRCLE_KEYS logic
                    // Find Key Data
                    // Note: CIRCLE_KEYS keys are Major. For 'sad' (minor), we might need relative handling.
                    // But simplified: 
                    // If mood is Sad, we assume Key passed is the Minor Key? 
                    // Or Key is Major and we derive? 
                    // Let's assume User selects the TONIC.
                    // If Sad C, it means C Minor. 
                    // C Minor relative is Eb Major.

                    // Complex mapping omitted for brevity, we will map Diatonic Major for happy, and treat input as Minor Tonic for sad?
                    // Let's stick to "Input is Key Center".

                    const chordHtml = prog.map(p => `<span>${p}</span>`).join(' - ');

                    card.innerHTML = `
                        <div style="font-weight:bold; font-size:1.2rem;">${chordHtml}</div>
                        <button class="action-btn" onclick="alert('Play feature coming soon')">‚ñ∂</button>
                    `;
                    out.appendChild(card);
                });
            }
        };

        const aiScaleRec = {
            find() {
                const input = document.getElementById('ai-scale-input').value;
                if (!input) return;

                // Save
                if (!appState.data.ai) appState.data.ai = {};
                appState.data.ai.lastScaleInput = input;
                appState.save();

                const out = document.getElementById('ai-scale-results');
                out.innerHTML = '';

                // Simple logic:
                // If "m" -> Minor, Pentatonic Minor, Blues
                // If "7" -> Mixolydian, Penta Maj?
                // If "maj7" -> Major, Lydian

                const suggestions = [];
                if (input.includes("m") && !input.includes("maj")) {
                    suggestions.push("Minor Pentatonic");
                    suggestions.push("Natural Minor (Aeolian)");
                    suggestions.push("Dorian (if ii chord)");
                    suggestions.push("Blues");
                } else if (input.includes("7") && !input.includes("maj")) {
                    suggestions.push("Minor Pentatonic (Bluesy)");
                    suggestions.push("Major Pentatonic (Country)");
                    suggestions.push("Mixolydian");
                } else {
                    // Major
                    suggestions.push("Major Pentatonic");
                    suggestions.push("Major (Ionian)");
                    suggestions.push("Lydian");
                }

                suggestions.forEach(s => {
                    const card = document.createElement('div');
                    card.className = 'scale-result-card';
                    card.innerHTML = `<div style="font-weight:600;">${s}</div><div style="color:#888; font-size:0.9rem;">Works well with ${input}</div>`;
                    out.appendChild(card);
                });
            }
        };


        const jamApp = {
            isPlaying: false,
            isRecording: false,
            style: 'rock',
            key: 'C',
            tempo: 100,

            init() {
                const s = appState.data.jam || {};
                this.style = s.style || 'rock';
                this.key = s.key || 'C';
                this.tempo = s.tempo || 100;

                // Restore UI
                document.getElementById('jam-style').value = this.style;
                document.getElementById('jam-key').value = this.key;
                document.getElementById('jam-tempo').value = this.tempo;
                document.getElementById('jam-bpm-val').innerText = this.tempo;
            },

            setStyle(val) {
                this.style = val;
                this.saveState();
                if (this.isPlaying) jamEngine.restart();
            },

            setKey(val) {
                this.key = val;
                this.saveState();
                // Update Scale Display immediately
                this.updateDisplay('I', 'Major');
            },

            setTempo(val) {
                this.tempo = parseInt(val);
                document.getElementById('jam-bpm-val').innerText = this.tempo;
                jamEngine.bpm = this.tempo;
                this.saveState();
            },

            togglePlay() {
                if (this.isPlaying) {
                    jamEngine.stop();
                    this.isPlaying = false;
                    document.getElementById('jam-play-btn').innerHTML = "&#9658; PLAY";
                    document.getElementById('jam-play-btn').classList.remove('active');
                } else {
                    jamEngine.start();
                    this.isPlaying = true;
                    document.getElementById('jam-play-btn').innerHTML = "&#9632; STOP";
                    document.getElementById('jam-play-btn').classList.add('active');
                }
            },

            toggleRecord() {
                if (this.isRecording) {
                    jamEngine.stopRecording();
                    this.isRecording = false;
                    document.getElementById('jam-rec-btn').innerHTML = "&#9679; REC";
                    document.getElementById('jam-rec-btn').classList.remove('active');
                    document.getElementById('jam-rec-btn').style.background = "#444";
                } else {
                    jamEngine.startRecording();
                    this.isRecording = true;
                    document.getElementById('jam-rec-btn').innerHTML = "&#9632; STOP REC";
                    document.getElementById('jam-rec-btn').classList.add('active');
                    document.getElementById('jam-rec-btn').style.background = "#FF5252";

                    // Auto play if not playing
                    if (!this.isPlaying) this.togglePlay();
                }
            },

            saveState() {
                if (!appState.data.jam) appState.data.jam = {};
                appState.data.jam.style = this.style;
                appState.data.jam.key = this.key;
                appState.data.jam.tempo = this.tempo;
                appState.save();
            },

            updateDisplay(chord, type) {
                // Update Now Playing
                document.getElementById('jam-chord-display').innerText = `${this.key} ${type === 'Major' ? '' : type}`;
                document.getElementById('jam-scale-display').innerText = `Scale: ${this.key} ${jamApp.style === 'blues' ? 'Blues' : 'Pentatonic'}`;
            },

            addRecording(blob) {
                const url = URL.createObjectURL(blob);
                const list = document.getElementById('jam-recordings-list');

                // Remove placeholder
                if (list.children.length > 0 && list.children[0].style.fontStyle === 'italic') {
                    list.innerHTML = '';
                }

                const item = document.createElement('div');
                item.className = 'card';
                item.style.padding = "10px";
                item.style.display = "flex";
                item.style.alignItems = "center";
                item.style.gap = "10px";

                const audio = document.createElement('audio');
                audio.controls = true;
                audio.src = url;
                audio.style.height = "30px";
                audio.style.flex = "1";

                const date = new Date().toLocaleTimeString();

                const label = document.createElement('div');
                label.innerText = `Jam ${date}`;
                label.style.fontSize = "0.8rem";

                // Download
                const downBtn = document.createElement('a');
                downBtn.href = url;
                downBtn.download = `Jam-${date}.webm`;
                downBtn.innerText = "‚¨á";
                downBtn.className = "action-btn";
                downBtn.style.padding = "5px 10px";

                item.appendChild(label);
                item.appendChild(audio);
                item.appendChild(downBtn);
                list.prepend(item);
            }
        };

        const jamEngine = {
            audioCtx: null,
            nextNoteTime: 0.0,
            timerID: null,
            isPlaying: false,
            bpm: 100,
            lookahead: 25.0,
            scheduleAheadTime: 0.1,

            // Recorder
            destNode: null,
            mediaRecorder: null,
            chunks: [],

            // State
            currentBeat: 0,
            currentBar: 0,

            // Instruments
            masterGain: null,

            start() {
                if (this.isPlaying) return;

                if (!this.audioCtx) {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.audioCtx.state === 'suspended') this.audioCtx.resume();

                // Master
                this.masterGain = this.audioCtx.createGain();
                this.masterGain.gain.value = 0.5;
                this.masterGain.connect(this.audioCtx.destination);

                // Hook for Recorder
                this.destNode = this.audioCtx.createMediaStreamDestination();
                this.masterGain.connect(this.destNode);

                this.isPlaying = true;
                this.bpm = jamApp.tempo;
                this.currentBeat = 0;
                this.currentBar = 0;
                this.nextNoteTime = this.audioCtx.currentTime + 0.1;

                this.scheduler();
            },

            stop() {
                this.isPlaying = false;
                window.clearTimeout(this.timerID);
                if (jamApp.isRecording) jamApp.toggleRecord(); // Stop rec if playing stops
            },

            restart() {
                if (this.isPlaying) {
                    this.stop();
                    setTimeout(() => this.start(), 100);
                }
            },

            startRecording() {
                if (!this.audioCtx) return;
                this.chunks = [];
                this.mediaRecorder = new MediaRecorder(this.destNode.stream);
                this.mediaRecorder.ondataavailable = (e) => this.chunks.push(e.data);
                this.mediaRecorder.onstop = (e) => {
                    const blob = new Blob(this.chunks, { 'type': 'audio/ogg; codecs=opus' });
                    jamApp.addRecording(blob);
                };
                this.mediaRecorder.start();
            },

            stopRecording() {
                if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                    this.mediaRecorder.stop();
                }
            },

            scheduler() {
                while (this.nextNoteTime < this.audioCtx.currentTime + this.scheduleAheadTime) {
                    this.scheduleBeat(this.currentBeat, this.nextNoteTime);
                    this.nextNote();
                }
                if (this.isPlaying) {
                    this.timerID = window.setTimeout(() => this.scheduler(), this.lookahead);
                }
            },

            nextNote() {
                const secondsPerBeat = 60.0 / this.bpm;
                this.nextNoteTime += secondsPerBeat; // Quarter notes
                this.currentBeat++;
                if (this.currentBeat >= 4) {
                    this.currentBeat = 0;
                    this.currentBar++;
                }
            },

            scheduleBeat(beat, time) {
                // Determine Chord from Progression
                // Simple I - IV - V - I for demo
                const prog = [1, 4, 5, 1]; // I IV V I
                const chordIdx = Math.floor(this.currentBar / 2) % 4; // 2 bars per chord
                const degree = prog[chordIdx];

                // Get Frequencies based on Key + Degree
                // Simplification for V1: Just offset from Root
                // Root Freq
                const rootFreq = tunerEngine.getNoteFreq(jamApp.key + "3"); // C3, G3 etc.

                // Calculate scale degree freq
                // Major Scale
                const scaleSteps = [0, 2, 4, 5, 7, 9, 11];
                const semi = scaleSteps[degree - 1]; // 0 for I, 5 for IV, 7 for V
                const chordRootFreq = rootFreq * Math.pow(2, semi / 12);

                // UI Update on Beat 0
                if (beat === 0 && this.currentBar % 2 === 0) {
                    // Main thread update (might be slightly off sync but okay for UI)
                    const chordName = degree === 1 ? 'I' : degree === 4 ? 'IV' : 'V';
                    requestAnimationFrame(() => {
                        jamApp.updateDisplay(chordName, 'Major');
                        document.getElementById('jam-next-chord').innerText = (degree === 1 || degree === 5) ? 'IV' : (degree === 4) ? 'V' : 'I';
                    });
                }

                this.playDrums(beat, time);
                this.playBass(beat, time, chordRootFreq);
                this.playChord(beat, time, chordRootFreq);
            },

            playDrums(beat, time) {
                // Simple Rock Beat
                const snare = (beat === 1 || beat === 3);
                const kick = (beat === 0 || beat === 2 || (beat === 2.5)); // Syncopated kick?

                if (beat === 0 || beat === 2) { // Kick
                    const osc = this.audioCtx.createOscillator();
                    const gain = this.audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(this.masterGain);

                    osc.frequency.setValueAtTime(150, time);
                    osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);

                    gain.gain.setValueAtTime(1, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);

                    osc.start(time);
                    osc.stop(time + 0.5);
                }

                if (beat === 1 || beat === 3) { // Snare (Noise)
                    const bufferSize = this.audioCtx.sampleRate * 0.1; // 100ms
                    const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }

                    const noise = this.audioCtx.createBufferSource();
                    noise.buffer = buffer;
                    const gain = this.audioCtx.createGain();
                    noise.connect(gain);
                    gain.connect(this.masterGain);

                    gain.gain.setValueAtTime(0.5, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                    noise.start(time);
                }

                // Hi-hat (8ths) - cheat, reuse noise with filter? OR just short tick
                // ...
            },

            playBass(beat, time, rootFreq) {
                // Root notes on 1 and 3
                if (beat === 0 || beat === 2) {
                    const osc = this.audioCtx.createOscillator();
                    osc.type = 'sawtooth';
                    const gain = this.audioCtx.createGain();
                    const filter = this.audioCtx.createBiquadFilter();

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.masterGain);

                    osc.frequency.value = rootFreq / 2; // Octave down
                    filter.frequency.value = 400;

                    gain.gain.setValueAtTime(0.4, time);
                    gain.gain.setTargetAtTime(0, time, 0.1);

                    osc.start(time);
                    osc.stop(time + 0.5);
                }
            },

            playChord(beat, time, rootFreq) {
                // Pad on beat 0
                if (beat === 0) {
                    // Major Triad (Root, 3rd, 5th)
                    const freqs = [
                        rootFreq,
                        rootFreq * Math.pow(2, 4 / 12),
                        rootFreq * Math.pow(2, 7 / 12)
                    ];

                    freqs.forEach(f => {
                        const osc = this.audioCtx.createOscillator();
                        osc.type = 'triangle';
                        const gain = this.audioCtx.createGain();
                        osc.connect(gain);
                        gain.connect(this.masterGain);

                        osc.frequency.value = f;
                        gain.gain.setValueAtTime(0.1, time);
                        gain.gain.setTargetAtTime(0, time + 2, 0.5); // Fade out over bar

                        osc.start(time);
                        osc.stop(time + 4); // Full bar
                    });
                }
            }
        };


        const theoryApp = {
            currentKeyIndex: 0, // start at C
            mode: 'major',
            isEnharmonic: false, // For F# vs Gb toggling if needed, simplified for now to just match data

            init() {
                // Load State
                const saved = appState.data.theory || {};
                this.currentKeyIndex = saved.keyIndex || 0;
                this.mode = saved.mode || 'major';

                // Initial Render
                this.renderWheel();
                this.updateInfo();

                // Set toggle UI initial state
                document.getElementById('theory-mode-toggle').textContent = this.mode === 'major' ? "Major" : "Minor";
            },

            renderWheel() {
                const svg = document.getElementById('theory-wheel-svg');
                if (!svg) return;
                svg.innerHTML = ''; // Clear

                const center = { x: 0, y: 0 };
                const radius = 100;
                const innerRadius = 60;

                // Draw Segments
                CIRCLE_KEYS.forEach((k, i) => {
                    // 12 segments = 30 degrees each
                    // Start at -90deg? 
                    // i=0 is C. top.
                    // standard circle drawing starts at 3 o clock (0 deg).
                    // we want C at -90 (12 o clock).
                    // SVG transform rotate(-90) handling?

                    const angleSize = 30;
                    const startAngle = (i * angleSize) - 90 - (angleSize / 2); // Center C at top
                    const endAngle = startAngle + angleSize;

                    // Convert polar to cartesian
                    const startRad = (startAngle * Math.PI) / 180;
                    const endRad = (endAngle * Math.PI) / 180;

                    const x1 = Math.cos(startRad) * radius;
                    const y1 = Math.sin(startRad) * radius;
                    const x2 = Math.cos(endRad) * radius;
                    const y2 = Math.sin(endRad) * radius;

                    const x3 = Math.cos(endRad) * innerRadius;
                    const y3 = Math.sin(endRad) * innerRadius;
                    const x4 = Math.cos(startRad) * innerRadius;
                    const y4 = Math.sin(startRad) * innerRadius;

                    // Path
                    // M outer1 A radius radius 0 0 1 outer2 L inner2 A inner radius 0 0 0 inner1 Z
                    const d = `
                        M ${x1} ${y1}
                        A ${radius} ${radius} 0 0 1 ${x2} ${y2}
                        L ${x3} ${y3}
                        A ${innerRadius} ${innerRadius} 0 0 0 ${x4} ${y4}
                        Z
                    `;

                    const grp = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    grp.onclick = () => this.setKey(i);
                    grp.style.cursor = 'pointer';

                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("d", d);
                    path.setAttribute("class", "wheel-segment");
                    if (i === this.currentKeyIndex) path.classList.add("active");
                    grp.appendChild(path);

                    // Label (centroid approx)
                    const midAngle = startAngle + (angleSize / 2);
                    const midRad = (midAngle * Math.PI) / 180;
                    const labelR = (radius + innerRadius) / 2;
                    const lx = Math.cos(midRad) * labelR;
                    const ly = Math.sin(midRad) * labelR;

                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute("x", lx);
                    text.setAttribute("y", ly);
                    text.setAttribute("class", "wheel-label");
                    // text.setAttribute("transform", `rotate(${midAngle + 90} ${lx} ${ly})`); // Rotate text? No, keep upright
                    text.textContent = k.key;

                    grp.appendChild(text);
                    svg.appendChild(grp);
                });
            },

            setKey(index) {
                this.currentKeyIndex = index;
                this.saveState();
                this.renderWheel(); // Update Active State
                this.updateInfo();
            },

            updateInfo() {
                const k = CIRCLE_KEYS[this.currentKeyIndex];

                // Key Logic
                let displayKey = k.key;
                if (this.mode === 'minor') displayKey = k.rel;

                // Update UI
                const keyNameEl = document.getElementById('theory-key-name');
                const relEl = document.getElementById('theory-rel-minor');
                const notesEl = document.getElementById('theory-scale-notes');
                const accEl = document.getElementById('theory-accidentals');
                const gridEl = document.getElementById('theory-chords-grid');

                if (keyNameEl) keyNameEl.textContent = displayKey + (this.mode === 'major' ? ' Major' : ' Minor');
                if (relEl) {
                    relEl.parentElement.querySelector('.info-label').textContent = this.mode === 'major' ? "Relative Minor" : "Relative Major";
                    relEl.textContent = this.mode === 'major' ? k.rel : k.key;
                }

                if (notesEl) notesEl.textContent = k.scale.join(' - ');
                if (accEl) accEl.textContent = k.acc > 0 ? `${k.acc} Sharps (#)` : k.acc < 0 ? `${Math.abs(k.acc)} Flats (b)` : 'Natural';

                // Chords Grid
                if (gridEl) {
                    gridEl.innerHTML = '';
                    const romanMaj = ["I", "ii", "iii", "IV", "V", "vi", "vii¬∞"];
                    const romanMin = ["i", "ii¬∞", "III", "iv", "v", "VI", "VII"];

                    const roman = this.mode === 'major' ? romanMaj : romanMin;

                    // Flattened list in 'diatonic' order
                    // Map C major chords: C Dm Em F G Am Bdim
                    // If Minor mode (Am): Am Bdim C Dm Em F G  (Starting from 6th index of major)

                    let chords = [...k.chords];
                    if (this.mode === 'minor') {
                        // Rotate array to start with relative minor (index 5)
                        const minorStart = chords.slice(5);
                        const majorPart = chords.slice(0, 5);
                        chords = [...minorStart, ...majorPart];
                    }

                    chords.forEach((chordName, idx) => {
                        const card = document.createElement('div');
                        card.className = 'degree-card';
                        card.innerHTML = `
                            <div class="degree-roman">${roman[idx]}</div>
                            <div class="degree-chord">${chordName}</div>
                        `;
                        card.onclick = () => this.loadChord(chordName);
                        gridEl.appendChild(card);
                    });
                }
            },

            toggleMode() {
                this.mode = this.mode === 'major' ? 'minor' : 'major';
                document.getElementById('theory-mode-toggle').textContent = this.mode === 'major' ? "Major" : "Minor";
                this.saveState();
                this.updateInfo();
            },

            saveState() {
                if (!appState.data.theory) appState.data.theory = {};
                appState.data.theory.keyIndex = this.currentKeyIndex;
                appState.data.theory.mode = this.mode;
                appState.save();
            },

            toggleEnharmonic() {
                // Just specific swaps for now as requested
                // Db <-> C#, F# <-> Gb, etc.
                // Re-render whole system? 
                alert("Enharmonic toggle coming soon!");
            },

            loadChord(chordName) {
                // Switch tab
                uiController.switchLearnView('chords');
                // Use handleSearch
                chordApp.handleSearch(chordName);
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            appState.init();
            uiController.init();
            chordApp.init();
            scaleApp.init(); // Init Scales
            theoryApp.init(); // Init Theory Wheel
            aiLabApp.init(); // Init AI Lab
            jamApp.init(); // Init Jam Mode
        });

    </script>
</body>

</html>